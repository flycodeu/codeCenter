## 软件开发原则
- 单一职责原则(SRP)
- 开闭原则(OCP)
- 里氏替换原则(LSP)
- 依赖倒置原则(DIP)
- 接口隔离原则(ISP)
- 迪米特法则(最少知道原则)
- 合成/聚合复用原则(CARP)

## 设计模式分类
- 根据作用范围:类/对象模式
- 根据目的分类:创建型/结构型/行为型模式
### 创建型模式:如何创建对象
- 单例模式(懒汉式、饿汉式、双检锁、线程唯一单例)
- 工厂方法模式(类)
- 抽象工厂模式
- 建造者模式
- 原型模式
### 结构型模式:如何将类或对象结合在一起形成一个更强大的结构
- 适配器模式(类/对象)
- 组合模式
- 装饰器模式
- 代理模式
- 享元模式
- 外观模式
- 桥接模式


### 行为型模式:类或对象间如何交互、如何划分职责,从而更好地完成任务
- 迭代器模式
- 模板方法模式(类)
- 策略模式
- 命令模式
- 状态模式
- 责任链模式
- 备忘录模式
- 观察者模式
- 访问者模式
- 中介者模式
- 解释器模式(类)

## 设计模式总体概括
[此图表来自schips](https://www.cnblogs.com/schips/p/12312385.html)

| 顺序 | 设计模式         | 常用程度 | 适用层次       | 引入时机      | 复杂度 | 变化                         | 实现                               | 体现的原则           |
|------|------------------|----------|----------------|---------------|--------|------------------------------|------------------------------------|----------------------|
| 1    | Factory Method   | 很常用   | 代码级         | 编码时        | 简单   | 子类的实例化                 | 对象的创建工作延迟到子类           | 开闭原则             |
| 2    | Singleton        | 很常用   | 代码级、应用级 | 设计时、编码时| 简单   | 唯一实例                     | 封装对象产生的个数                 |                      |
| 3    | Facade           | 很常用   | 应用级、构架级 | 设计时、编码时| 简单   | 子系统的高层接口             | 封装子系统                         | 开闭原则             |
| 4    | Template Method  | 很常用   | 代码级         | 编码时、重构时| 简单   | 算法子步骤的变化             | 封装算法结构                       | 依赖倒置原则         |
| 5    | Abstract Factory | 较常用   | 应用级         | 设计时        | 较复杂 | 产品家族的扩展               | 封装产品族系列内容的创建           | 开闭原则             |
| 6    | Composite        | 较常用   | 代码级         | 编码时、重构时| 较复杂 | 复杂对象接口的统一           | 统一复杂对象的接口                 | 里氏代换原则         |
| 7    | Proxy            | 较常用   | 应用级、构架级 | 设计时、编码时| 简单   | 对象访问的变化               | 封装对象的访问过程                 | 里氏代换原则         |
| 8    | Command          | 较常用   | 应用级         | 设计时、编码时| 较简单 | 请求的变化                   | 封装行为对对象                     | 开闭原则             |
| 9    | Observer         | 较常用   | 应用级、构架级 | 设计时、编码时| 较简单 | 通讯对象的变化               | 封装对象通知                       | 开闭原则             |
| 10   | Strategy         | 较常用   | 应用级         | 设计时        | 一般   | 算法的变化                   | 封装算法                           | 里氏代换原则         |
| 11   | Builder          | 一般     | 代码级         | 编码时        | 一般   | 对象组建的变化               | 封装对象的组建过程                 | 开闭原则             |
| 12   | Adapter          | 一般     | 代码级         | 重构时        | 一般   | 对象接口的变化               | 接口的转换                         |                      |
| 13   | Bridge           | 一般     | 代码级         | 设计时、编码时| 一般   | 对象的多维度变化             | 分离接口以及实现                   | 开闭原则             |
| 14   | Decorator        | 一般     | 代码级         | 重构时        | 较复杂 | 对象的组合职责               | 在稳定接口上扩展                   | 开闭原则             |
| 15   | Iterator         | 一般     | 代码级、应用级 | 编码时、重构时| 较简单 | 对象内部集合的变化           | 封装对象内部集合的使用             | 单一职责原则         |
| 16   | Mediator         | 一般     | 应用级、构架级 | 编码时、重构时| 一般   | 对象交互的变化               | 封装对象间的交互                   | 开闭原则             |
| 17   | Memento          | 一般     | 代码级         | 编码时        | 较简单 | 状态的辅助保存               | 封装对象状态的变化                 | 接口隔离原则         |
| 18   | State            | 一般     | 应用级         | 设计时、编码时| 一般   | 对象状态的变化               | 封装与状态相关的行为               | 单一职责原则         |
| 19   | Visitor          | 一般     | 应用级         | 设计时        | 较复杂 | 对象操作变化                 | 封装对象操作变化                   | 开闭原则             |
| 20   | Prototype        | 不太常用 | 应用级         | 编码时、重构时| 较简单 | 实例化的类                   | 封装对原型的拷贝                   | 依赖倒置原则         |
| 21   | Flyweight        | 不太常用 | 代码级、应用级 | 设计时        | 一般   | 系统开销的优化               | 封装对象的获取                     |                      |
| 22   | Chain of Resp.   | 不太常用 | 应用级、构架级 | 设计时、编码时| 较复杂 | 对象的请求过程               | 封装对象的责任范围                 |                      |
| 23   | Interpreter      | 不太常用 | 应用级         | 设计时        | 较复杂 | 领域问题的变化               | 封装特定领域的变化                 |                      |

[命令模式](命令模式.md)

将一个请求分装成一个对象，从而可以使用不同的请求对客户进行参数化

[单例模式](单例模式.md)

保证一个类只有一个实例，并且能够提供一个访问它的全局访问点。

[模板方法模式](模板方法模式.md)

定义一个操作中的算法骨架，将一些步骤延迟到子类里面。
