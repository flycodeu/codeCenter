---
title: 从 0 到 1 构建企业级视频智能分析平台：完整工程实践
createTime: 2026/02/13 14:24:10
permalink: /article/sdzvcf45/
tags:
   - MediaMTX
   - FFmpeg
   - WebSocket
cover: https://flycodeu-1314556962.cos.ap-nanjing.myqcloud.com/codeCenterImg/5cbc6cde5e42790b07d060f5792b1b6f.jpg
---
<ImageCard
image="https://flycodeu-1314556962.cos.ap-nanjing.myqcloud.com/codeCenterImg/5cbc6cde5e42790b07d060f5792b1b6f.jpg"
href="/"
width=400
center=true
/>

# 从 0 到 1 构建企业级视频智能分析平台：完整工程实践

> **一份可直接落地的全栈技术方案**
>  覆盖相机接入、流媒体编排、存储治理、智能分析全链路
>  包含架构设计、核心代码、数据模型、运维体系与性能基准

------

## 目录

### 第一部分：平台基础与相机接入

1. [问题定义与架构设计](#1-问题定义与架构设计)
2. [技术选型与核心组件](#2-技术选型与核心组件)
3. [数据模型设计](#3-数据模型设计)
4. [ONVIF 协议深度解析与实现](#4-onvif-协议深度解析与实现)
5. [MediaMTX 流媒体网关集成](#5-mediamtx-流媒体网关集成)
6. [FFmpeg 编解码治理](#6-ffmpeg-编解码治理)
7. [相机接入完整流程](#7-相机接入完整流程)
8. [设备状态巡检与事件闭环](#8-设备状态巡检与事件闭环)

### 第二部分：录像存储系统

1. [录像系统架构设计](#9-录像系统架构设计)
2. [存储卷治理与容量管理](#10-存储卷治理与容量管理)
3. [录像策略编排](#11-录像策略编排)
4. [文件索引与回放检索](#12-文件索引与回放检索)

### 第三部分：智能分析平台

1. [算法任务模型设计](#13-算法任务模型设计)
2. [算法节点管理与调度](#14-算法节点管理与调度)
3. [WebSocket 协议规范](#15-websocket-协议规范)
4. [结果处理与告警推送](#16-结果处理与告警推送)
5. [预览链路实现](#17-预览链路实现)

### 第四部分：运维与演进

1. [配置管理](#18-配置管理)
2. [可观测性体系](#19-可观测性体系)
3. [典型问题与解决方案](#20-典型问题与解决方案)
4. [FAQ 与最佳实践](#21-faq-与最佳实践)
5. [性能基准与压测](#22-性能基准与压测)
6. [架构演进路线](#23-架构演进路线)

------

## 第一部分：平台基础与相机接入

### 1. 问题定义与架构设计

#### 1.1 业务背景与核心挑战

在构建视频智能分析平台的过程中,我们面临着多个维度的工程挑战:

**设备层异构性**

- 不同厂商的 ONVIF 协议实现质量参差不齐,部分设备仅支持核心功能子集
- 编码格式混乱:H.264、H.265、MJPEG 共存,浏览器兼容性差异显著
- 网络拓扑复杂:设备位于内网,播放端在外网,NAT 穿透成为常态

**状态管理复杂性**

- 控制平面可达但媒体平面不可达的"假在线"现象
- 设备离线后缺少事件追踪,无法形成运维闭环
- 流地址变化频繁,缺少统一的路径抽象

**扩展性瓶颈**

- 录像、算法等下游服务直接依赖设备原始 RTSP,耦合过深
- 缺少统一的媒体出口,后续功能扩展需要大量重复工作
- 编码转换策略不清晰,成本与质量难以平衡

#### 1.2 设计目标

基于上述问题,我们设定了分阶段的建设目标:

**第一阶段:建立可扩展底座**

1. **统一接入层**:设备能力发现、凭据校验、元信息持久化
2. **统一流模型**:自动生成主/子码流路径,建立路径到设备的映射关系
3. **统一媒体出口**:通过 MediaMTX 提供可控、可观测的播放入口
4. **编码治理**:先探测、后决策,按需转码,控制成本
5. **状态闭环**:在线巡检 + 离线事件追踪,形成完整生命周期管理

**第二阶段:录像与存储**

1. 录像策略模型化,支持多种录制模式
2. 存储卷治理,容量可观测、可切换
3. 文件索引构建,回放检索高效化

**第三阶段:智能分析**

1. 一个任务绑定一台相机,支持多算法场景并行
2. 算法节点能力建模与调度
3. 实时结果处理与告警分发

#### 1.3 总体架构

我们采用分层解耦的架构设计:

```
┌─────────────────────────────────────────────────────────┐
│                      API Gateway                        │
│            (RESTful API + WebSocket)                    │
└────────────────┬────────────────────────────────────────┘
                 │
┌────────────────┴────────────────────────────────────────┐
│                  Application Layer                      │
│  ┌──────────────┬──────────────┬─────────────────────┐ │
│  │ 相机接入服务  │ 录像编排服务  │ 算法任务编排服务     │ │
│  └──────────────┴──────────────┴─────────────────────┘ │
└────────────────┬────────────────────────────────────────┘
                 │
┌────────────────┴────────────────────────────────────────┐
│              Infrastructure Layer                       │
│  ┌──────────────┬──────────────┬─────────────────────┐ │
│  │ ONVIF 适配层 │ MediaMTX网关  │ FFmpeg编码引擎      │ │
│  └──────────────┴──────────────┴─────────────────────┘ │
│  ┌──────────────┬──────────────┬─────────────────────┐ │
│  │   MySQL      │ 存储卷管理    │ 算法节点池           │ │
│  └──────────────┴──────────────┴─────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

**核心设计原则**

1. **控制面与媒体面解耦**
    - ONVIF 负责设备能力发现和控制指令
    - MediaMTX 负责媒体流路径管理和分发
    - 两者通过数据库中的路径映射关联
2. **路径抽象统一化**
    - 所有下游服务(录像/算法/播放)只依赖平台分配的路径
    - 设备地址变化时,只需更新路径配置,不影响消费端
3. **异步化与容错**
    - 接入流程中的流同步采用异步执行
    - 媒体注册失败支持延迟重试
    - 关键操作支持事务回滚

------

### 2. 技术选型与核心组件

#### 2.1 ONVIF 协议详解

**什么是 ONVIF**

ONVIF (Open Network Video Interface Forum) 是一个开放的网络视频设备接口标准,旨在实现不同厂商的 IP 摄像机、录像机和视频管理软件之间的互操作性。ONVIF 基于 Web Services 技术栈,核心协议包括:

- **SOAP (Simple Object Access Protocol)**:消息封装协议
- **WSDL (Web Services Description Language)**:服务描述语言
- **WS-Security**:安全认证机制
- **WS-Discovery**:设备发现协议

**ONVIF 服务架构**

ONVIF 将功能划分为多个服务端点:

1. **Device Service** (`/onvif/device_service`)
    - 设备基础信息 (厂商、型号、序列号、固件版本)
    - 系统时间同步
    - 能力集发现 (Capabilities)
    - 网络配置
2. **Media Service** (`/onvif/media_service`)
    - Profile 管理 (流配置)
    - 获取 RTSP URI
    - 获取快照 URI
    - 视频编码器配置
3. **PTZ Service** (`/onvif/ptz_service`)
    - 云台控制
    - 预置位管理
4. **Events Service** (`/onvif/events_service`)
    - 事件订阅
    - 运动检测通知

**为什么选择 ONVIF**

1. **标准化程度高**:主流厂商均支持,减少适配成本
2. **功能完整性**:覆盖设备管理到媒体控制的全生命周期
3. **可扩展性强**:通过 Profile 机制支持不同能力级别
4. **生态成熟**:丰富的开源库和工具链

**ONVIF 的局限性与应对**

1. **厂商实现差异**
    - 问题:部分厂商仅实现 Profile S (Streaming),缺少 PTZ 等扩展能力
    - 应对:设计时采用能力发现机制,降级处理缺失功能
2. **性能开销**
    - 问题:SOAP 协议 XML 解析开销较大
    - 应对:缓存设备信息,减少重复调用;关键路径使用连接池
3. **时间同步敏感**
    - 问题:WS-Security 要求客户端与设备时间误差小于 5 秒
    - 应对:定期校准服务器 NTP;捕获时间窗口错误并重试

#### 2.2 MediaMTX 流媒体网关

**什么是 MediaMTX**

MediaMTX (前身为 rtsp-simple-server) 是一个现代化的实时流媒体服务器,支持多种协议的统一接入和分发:

- **输入协议**:RTSP、RTMP、HLS、WebRTC、SRT
- **输出协议**:RTSP、HLS、WebRTC
- **核心特性**:
    - 按需拉流 (sourceOnDemand)
    - 按需转码 (runOnDemand)
    - RESTful API 动态配置
    - 低延迟 WebRTC 推流

**MediaMTX 的技术优势**

1. **轻量级架构**
    - 单一 Go 二进制,资源占用低
    - 无外部依赖,部署简单
2. **协议转换能力**
    - 统一的内部流模型
    - 自动协议适配,降低客户端复杂度
3. **动态路径管理**
    - 支持运行时添加/删除路径
    - 版本化配置接口

**MediaMTX 在本架构中的作用**

1. **统一媒体出口**
    - 所有 RTSP 源流接入 MediaMTX
    - 对外提供标准化的播放地址
2. **按需资源调度**
    - `sourceOnDemand`:无客户端时不拉流,节省带宽
    - `runOnDemand`:触发 FFmpeg 转码进程
3. **录像与预览集成**
    - 原生支持切片录像
    - 实时预览与录像共享同一路径

**MediaMTX 路径配置示例**

```yaml
paths:
  cam_10_0_1_20_ch1_main:
    source: rtsp://admin:pass@10.0.1.20:554/Streaming/Channels/101
    sourceOnDemand: yes
    sourceOnDemandStartTimeout: 10s
    sourceOnDemandCloseAfter: 10s
    
    # 录像配置
    record: yes
    recordPath: /recordings/%path/%Y-%m-%d/%H-%M-%S
    recordFormat: fmp4
    recordSegmentDuration: 10m
    recordDeleteAfter: 7d
```

#### 2.3 FFmpeg 编解码工具链

**什么是 FFmpeg**

FFmpeg 是一个完整的跨平台音视频处理工具集,包含:

- **ffmpeg**:转码工具
- **ffprobe**:流分析工具
- **ffplay**:播放器
- **libav***:编解码库

**核心概念**

1. **容器 (Container)**
    - 文件格式,如 MP4、FLV、TS
    - 存储音视频流的封装层
2. **编解码器 (Codec)**
    - 视频:H.264、H.265 (HEVC)、VP9、AV1
    - 音频:AAC、MP3、Opus
3. **滤镜 (Filter)**
    - 视频处理:缩放、裁剪、叠加
    - 音频处理:混音、变速

**常用命令详解**

**1. ffprobe 流探测**

```bash
ffprobe -v error \
  -rtsp_transport tcp \
  -analyzeduration 1000000 \
  -probesize 32768 \
  -select_streams v:0 \
  -show_entries stream=codec_name,width,height,avg_frame_rate \
  -of json \
  "rtsp://admin:pass@10.0.1.20:554/Streaming/Channels/101"
```

**参数解释**:

- `-v error`:仅输出错误信息
- `-rtsp_transport tcp`:强制使用 TCP (避免 UDP 丢包)
- `-analyzeduration`:分析时长 (微秒)
- `-probesize`:探测数据大小 (字节)
- `-select_streams v:0`:仅选择第一个视频流
- `-show_entries`:指定输出字段
- `-of json`:输出格式为 JSON

**输出示例**:

```json
{
  "streams": [{
    "codec_name": "h264",
    "width": 1920,
    "height": 1080,
    "avg_frame_rate": "25/1"
  }]
}
```

**2. H.265 转 H.264**

```bash
ffmpeg -hide_banner -loglevel warning \
  -rtsp_transport tcp \
  -stimeout 5000000 \
  -i "rtsp://admin:pass@10.0.1.20:554/Streaming/Channels/101" \
  -an \
  -c:v libx264 \
  -preset veryfast \
  -crf 23 \
  -tune zerolatency \
  -pix_fmt yuv420p \
  -g 50 \
  -keyint_min 50 \
  -sc_threshold 0 \
  -x264-params repeat-headers=1 \
  -f rtsp \
  -rtsp_transport tcp \
  "rtsp://127.0.0.1:8554/output"
```

**关键参数说明**:

- `-an`:禁用音频 (减少处理开销)
- `-c:v libx264`:使用 x264 编码器
- `-preset veryfast`:编码速度预设 (速度优先)
- `-crf 23`:恒定质量因子 (18-28,值越小质量越高)
- `-tune zerolatency`:优化低延迟场景
- `-pix_fmt yuv420p`:像素格式 (浏览器兼容)
- `-g 50`:GOP 大小 (关键帧间隔)
- `-sc_threshold 0`:禁用场景切换检测
- `-x264-params repeat-headers=1`:每个关键帧重复 SPS/PPS

**3. 硬件加速转码 (NVIDIA)**

```bash
ffmpeg -hwaccel cuda -hwaccel_output_format cuda \
  -i input.mp4 \
  -c:v h264_nvenc \
  -preset p4 \
  -b:v 3000k \
  output.mp4
```

**参数说明**:

- `-hwaccel cuda`:启用 CUDA 硬件加速
- `-hwaccel_output_format cuda`:保持 GPU 内存格式
- `-c:v h264_nvenc`:使用 NVENC 编码器
- `-preset p4`:性能预设 (p1 最快, p7 最慢)

**FFmpeg 在本平台中的应用**

1. **编码探测**
    - 接入时探测设备编码格式
    - 决策是否需要转码
2. **实时转码**
    - H.265 -> H.264 兼容性转换
    - 分辨率/码率自适应
3. **录像导出**
    - 按时间范围裁剪
    - 多切片拼接

------

### 3. 数据模型设计

数据模型是整个系统的基础,直接决定了后续查询效率、扩展性和运维复杂度。我们遵循以下设计原则:

1. **职责单一**:每张表只负责一类业务实体
2. **冗余可控**:适度冗余提升查询性能,但避免数据不一致
3. **索引精准**:基于实际查询模式建立索引
4. **字段语义化**:使用明确的枚举值,避免魔法数字

#### 3.1 设备主档表

```sql
DROP TABLE IF EXISTS `camera_device`;
CREATE TABLE `camera_device` (
  `id`               BIGINT NOT NULL COMMENT '主键ID',
  `camera_name`      VARCHAR(100) DEFAULT NULL COMMENT '设备名称',
  `group_id`         BIGINT DEFAULT NULL COMMENT '分组ID',

  -- ONVIF 连接信息
  `ip`               VARCHAR(50) NOT NULL COMMENT '设备IP',
  `port`             INT NOT NULL DEFAULT 80 COMMENT 'ONVIF端口',
  `username`         VARCHAR(50) NOT NULL COMMENT 'ONVIF用户名',
  `password`         VARCHAR(255) NOT NULL COMMENT 'ONVIF密码(AES加密)',

  -- 设备元信息
  `serial_number`    VARCHAR(100) DEFAULT NULL COMMENT '序列号',
  `manufacturer`     VARCHAR(100) DEFAULT NULL COMMENT '厂商',
  `model`            VARCHAR(100) DEFAULT NULL COMMENT '型号',
  `firmware_version` VARCHAR(100) DEFAULT NULL COMMENT '固件版本',

  -- 状态字段
  `camera_status`    INT DEFAULT 0 COMMENT '1在线 0离线',
  `last_online_time` DATETIME DEFAULT NULL COMMENT '最后在线时间',

  -- 审计字段
  `create_user`      BIGINT DEFAULT NULL,
  `create_dept`      BIGINT DEFAULT NULL,
  `create_time`      DATETIME DEFAULT CURRENT_TIMESTAMP,
  `update_user`      BIGINT DEFAULT NULL,
  `update_time`      DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `status`           INT DEFAULT 1 COMMENT '1启用 0停用',
  `is_deleted`       INT DEFAULT 0 COMMENT '1已删除 0正常',

  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_ip_is_deleted` (`ip`, `is_deleted`),
  KEY `idx_group_id` (`group_id`),
  KEY `idx_camera_status` (`camera_status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='相机设备主档表';
```

**设计要点**:

1. **唯一性约束**
    - `uk_ip_is_deleted`:同一 IP 的有效设备全局唯一
    - 支持软删除后重新接入
2. **状态索引**
    - `idx_camera_status`:支持在线/离线设备快速筛选
    - 用于首页统计看板
3. **安全性**
    - `password` 字段应使用 AES 加密存储
    - 日志输出时需脱敏处理

#### 3.2 分组表

```sql
DROP TABLE IF EXISTS `camera_group`;
CREATE TABLE `camera_group` (
  `id`          BIGINT NOT NULL AUTO_INCREMENT,
  `group_name`  VARCHAR(100) NOT NULL COMMENT '分组名称',
  `parent_id`   BIGINT DEFAULT NULL COMMENT '父分组ID',
  `group_type`  TINYINT DEFAULT 0 COMMENT '0普通分组 1地理分组 2功能分组',
  `sort_order`  INT DEFAULT 0 COMMENT '排序',
  `icon`        VARCHAR(50) DEFAULT NULL COMMENT '图标',
  `description` VARCHAR(500) DEFAULT NULL COMMENT '描述',

  `create_user` BIGINT DEFAULT NULL,
  `create_dept` BIGINT DEFAULT NULL,
  `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP,
  `update_user` BIGINT DEFAULT NULL,
  `update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `status`      INT DEFAULT 1,
  `is_deleted`  TINYINT DEFAULT 0,

  PRIMARY KEY (`id`),
  KEY `idx_parent_id` (`parent_id`),
  KEY `idx_group_type` (`group_type`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='相机分组表';
```

**设计要点**:

1. **树形结构**
    - 支持多级分组
    - 通过 `parent_id` 构建层级关系
2. **类型扩展**
    - `group_type` 预留不同分组语义
    - 便于后续按地理位置、功能区域等维度组织

#### 3.3 流路径表

```sql
DROP TABLE IF EXISTS `camera_stream_path`;
CREATE TABLE `camera_stream_path` (
  `id`             BIGINT NOT NULL COMMENT '主键ID',
  `camera_id`      BIGINT NOT NULL COMMENT '设备ID',
  `path_name`      VARCHAR(255) NOT NULL COMMENT '媒体路径主键',
  `source_url`     VARCHAR(1000) DEFAULT NULL COMMENT 'RTSP源地址',

  -- ONVIF Profile 信息
  `profile_token`  VARCHAR(64) DEFAULT NULL COMMENT 'ONVIF ProfileToken',
  `profile_name`   VARCHAR(100) DEFAULT NULL COMMENT 'Profile名称',
  `video_encoding` VARCHAR(20) DEFAULT NULL COMMENT '编码格式(原始)',
  `video_codec`    VARCHAR(16) DEFAULT NULL COMMENT '标准化编码(H264/H265/HEVC)',
  `resolution`     VARCHAR(20) DEFAULT NULL COMMENT '分辨率',
  `subtype`        INT NOT NULL DEFAULT 0 COMMENT '0主码流 1子码流',
  `channel`        INT DEFAULT NULL COMMENT '通道号',
  `need_transcode` TINYINT(1) NOT NULL DEFAULT 0 COMMENT '是否转码',

  -- 状态字段
  `enabled`        TINYINT NOT NULL DEFAULT 1 COMMENT '1启用 0停用',
  `status`         INT NOT NULL DEFAULT 1 COMMENT '1可用 0失败',

  `create_time`    DATETIME DEFAULT CURRENT_TIMESTAMP,
  `update_time`    DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_path_name` (`path_name`),
  KEY `idx_camera_id` (`camera_id`),
  KEY `idx_codec_transcode` (`video_codec`, `need_transcode`),
  KEY `idx_channel_subtype` (`camera_id`, `channel`, `subtype`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='流路径表';
```

**设计要点**:

1. **路径唯一性**
    - `uk_path_name`:全局唯一的媒体入口标识
    - 所有下游服务依赖此路径
2. **编码决策字段**
    - `video_codec`:标准化编码格式
    - `need_transcode`:转码决策结果
    - 索引支持"按编码类型统计转码比例"
3. **流类型约束**
    - `(camera_id, channel, subtype)`:保证同设备同通道同类型只有一个生效路径

#### 3.4 离线事件表

```sql
DROP TABLE IF EXISTS `camera_offline_event`;
CREATE TABLE `camera_offline_event` (
  `id`              BIGINT NOT NULL AUTO_INCREMENT,
  `device_id`       BIGINT NOT NULL COMMENT '设备ID',
  `device_ip`       VARCHAR(50) DEFAULT NULL COMMENT '设备IP(冗余)',
  `group_id`        BIGINT DEFAULT NULL COMMENT '分组ID(冗余)',

  -- 事件时间线
  `start_time`      DATETIME NOT NULL COMMENT '离线开始时间',
  `last_check_time` DATETIME NOT NULL COMMENT '最后检测时间',
  `end_time`        DATETIME DEFAULT NULL COMMENT '恢复在线时间',
  `duration`        BIGINT DEFAULT 0 COMMENT '离线时长(秒)',

  -- 事件状态
  `is_resolved`     TINYINT DEFAULT 0 COMMENT '1已恢复 0未恢复',
  `alarm_status`    TINYINT DEFAULT 0 COMMENT '1已告警 0未告警',
  `remark`          VARCHAR(255) DEFAULT NULL COMMENT '备注',

  `create_time`     DATETIME DEFAULT CURRENT_TIMESTAMP,
  `update_time`     DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,

  PRIMARY KEY (`id`),
  KEY `idx_device_status` (`device_id`, `is_resolved`),
  KEY `idx_time` (`start_time`, `end_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='设备离线事件表';
```

**设计要点**:

1. **事件闭环**
    - `is_resolved`:区分进行中和已结束事件
    - `duration`:离线时长统计

2. **冗余字段**
    - `device_ip`/`group_id`:避免关联查询
    - 用于告警消息快速组装

3. **时间索引**
    - 支持按时间范围查询历史离线记录
    - 用于生成离线率报表

---

### 4. ONVIF 协议深度解析与实现

#### 4.1 ONVIF 调用最小可用集

在实际生产环境中,并非所有 ONVIF 接口都需要实现。我们根据业务需求,定义了**最小可用集**:

| 接口                   | 服务   | 用途                          | 调用时机   |
| ---------------------- | ------ | ----------------------------- | ---------- |
| `GetDeviceInformation` | Device | 获取厂商/型号/序列号/固件版本 | 设备接入时 |
| `GetCapabilities`      | Device | 获取各服务端点地址            | 设备接入时 |
| `GetProfiles`          | Media  | 获取流配置列表                | 流同步时   |
| `GetStreamUri`         | Media  | 获取 RTSP 播放地址            | 流同步时   |
| `GetSnapshotUri`       | Media  | 获取快照地址                  | 流同步时   |
| `GetSystemDateAndTime` | Device | 获取设备时间                  | 在线心跳   |

**为什么是这 6 个接口?**

1. **接入必需**:`GetDeviceInformation` 和 `GetCapabilities` 是设备身份识别和能力发现的基础
2. **流管理核心**:`GetProfiles`、`GetStreamUri`、`GetSnapshotUri` 构成完整的媒体流管理
3. **状态监控**:`GetSystemDateAndTime` 作为心跳接口,开销小且稳定

#### 4.2 设备侧配置要求

很多接入失败的根因不是代码问题,而是设备侧未正确配置。建议在接入前逐项确认:

**1. 服务开启**
- ✅ ONVIF 服务已启用
- ✅ RTSP 服务已启用
- ❌ 常见错误:只开启了 Web 管理,未开启 ONVIF

**2. 账号权限**
```
建议创建专用 ONVIF 账号,而非复用管理员账号
最小权限集:
  - 读取设备信息
  - 读取媒体配置
  - 读取流 URI
不需要:
  - PTZ 控制权限
  - 参数修改权限
```

**3. 时间同步**

```bash
# NTP 配置示例 (设备端)
NTP Server: ntp.aliyun.com
Time Zone: GMT+8
Sync Interval: 3600s
```

**原因**:WS-Security 要求客户端与设备时间误差 < 5 秒

**4. 网络配置**

```
防火墙规则:
  允许入站: TCP 80 (ONVIF), TCP 554 (RTSP)
  允许出站: TCP 任意 (用于 RTSP 数据回传)

跨网段访问:
  确保路由可达
  确认 NAT 规则 (若设备在内网)
```

#### 4.3 WS-Security 认证实现

ONVIF 使用 **UsernameToken** 认证方式,核心步骤:

**1. 生成 Nonce**

```java
byte[] nonce = new byte[16];
SecureRandom.getInstanceStrong().nextBytes(nonce);
String nonceBase64 = Base64.getEncoder().encodeToString(nonce);
```

**2. 获取 UTC 时间**

```java
String created = ZonedDateTime.now(ZoneOffset.UTC)
    .format(DateTimeFormatter.ISO_INSTANT);
// 示例: 2026-02-13T14:30:00.000Z
```

**3. 计算 PasswordDigest**

```java
byte[] digest = MessageDigest.getInstance("SHA-1").digest(
    (nonce + created + password).getBytes(StandardCharsets.UTF_8)
);
String passwordDigest = Base64.getEncoder().encodeToString(digest);
```

**完整 SOAP 请求封装**

```java
public class OnvifSoapClient {
    
    public Document sendSoapRequest(String url, String username, String password, String body) 
            throws Exception {
        String envelope = buildSoapEnvelope(username, password, body);
        
        HttpResponse response = HttpRequest.post(url)
            .header("Content-Type", "application/soap+xml; charset=utf-8")
            .timeout(5000)
            .body(envelope)
            .execute();
        
        if (!response.isOk()) {
            throw new OnvifException("HTTP " + response.getStatus());
        }
        
        Document doc = XmlUtil.readXML(response.body());
        validateSoapFault(doc);
        return doc;
    }
    
    private String buildSoapEnvelope(String username, String password, String body) {
        String created = utcNow();
        byte[] nonce = generateNonce();
        String nonceBase64 = Base64.getEncoder().encodeToString(nonce);
        String digest = calculateDigest(nonce, created, password);
        
        return "<?xml version=\"1.0\" encoding=\"utf-8\"?>" +
            "<s:Envelope xmlns:s=\"http://www.w3.org/2003/05/soap-envelope\">" +
            "<s:Header>" +
            "<Security s:mustUnderstand=\"1\" " +
            "xmlns=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\">" +
            "<UsernameToken>" +
            "<Username>" + username + "</Username>" +
            "<Password Type=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest\">" +
            digest + "</Password>" +
            "<Nonce EncodingType=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary\">" +
            nonceBase64 + "</Nonce>" +
            "<Created xmlns=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">" +
            created + "</Created>" +
            "</UsernameToken>" +
            "</Security>" +
            "</s:Header>" +
            "<s:Body>" + body + "</s:Body>" +
            "</s:Envelope>";
    }
    
    private void validateSoapFault(Document doc) throws OnvifFaultException {
        NodeList faults = doc.getElementsByTagNameNS("*", "Fault");
        if (faults.getLength() > 0) {
            Element fault = (Element) faults.item(0);
            String code = getTextContent(fault, "Code", "Value");
            String reason = getTextContent(fault, "Reason", "Text");
            throw new OnvifFaultException(code, reason);
        }
    }
}
```

**为什么必须验证 SOAP Fault?**

大量设备会返回 **HTTP 200 + SOAP Fault**,如果不解析 Fault,会导致:

1. 接入误成功,产生脏数据
2. 在线误判,影响运维决策
3. 错误告警,消耗人工排查成本

**常见 SOAP Fault 示例**

```xml
<s:Envelope>
  <s:Body>
    <s:Fault>
      <s:Code>
        <s:Value>s:Sender</s:Value>
        <s:Subcode>
          <s:Value>ter:InvalidArgVal</s:Value>
        </s:Subcode>
      </s:Code>
      <s:Reason>
        <s:Text xml:lang="en">Invalid ProfileToken</s:Text>
      </s:Reason>
    </s:Fault>
  </s:Body>
</s:Envelope>
```

#### 4.4 核心接口调用示例

**1. GetDeviceInformation**

```java
public class OnvifDeviceService {
    
    public DeviceInfo getDeviceInformation(String ip, int port, String user, String pass) 
            throws OnvifException {
        String url = String.format("http://%s:%d/onvif/device_service", ip, port);
        String body = "<tds:GetDeviceInformation xmlns:tds=\"http://www.onvif.org/ver10/device/wsdl\" />";
        
        Document doc = soapClient.sendSoapRequest(url, user, pass, body);
        
        return DeviceInfo.builder()
            .manufacturer(getText(doc, "Manufacturer"))
            .model(getText(doc, "Model"))
            .firmwareVersion(getText(doc, "FirmwareVersion"))
            .serialNumber(getText(doc, "SerialNumber"))
            .hardwareId(getText(doc, "HardwareId"))
            .build();
    }
}
```

**响应示例**:

```xml
<GetDeviceInformationResponse>
  <Manufacturer>Hikvision</Manufacturer>
  <Model>DS-2CD2142FWD-I</Model>
  <FirmwareVersion>V5.5.0</FirmwareVersion>
  <SerialNumber>DS-2CD2142FWD-I20180101AAWRB12345678</SerialNumber>
  <HardwareId>88</HardwareId>
</GetDeviceInformationResponse>
```

**2. GetCapabilities**

```java
public Capabilities getCapabilities(String ip, int port, String user, String pass) 
        throws OnvifException {
    String url = String.format("http://%s:%d/onvif/device_service", ip, port);
    String body = 
        "<tds:GetCapabilities xmlns:tds=\"http://www.onvif.org/ver10/device/wsdl\">" +
        "<tds:Category>Media</tds:Category>" +
        "</tds:GetCapabilities>";
    
    Document doc = soapClient.sendSoapRequest(url, user, pass, body);
    
    String mediaXAddr = getText(doc, "Media", "XAddr");
    if (mediaXAddr == null || mediaXAddr.isEmpty()) {
        // 降级处理:使用 Device Service 地址
        mediaXAddr = url;
    }
    
    return Capabilities.builder()
        .mediaXAddr(mediaXAddr)
        .build();
}
```

**为什么需要 GetCapabilities?**

不同设备的服务端点地址可能不同:

- 标准地址:`http://10.0.1.20/onvif/media_service`
- 厂商定制:`http://10.0.1.20/onvif/device_service`
- 带端口:`http://10.0.1.20:8080/onvif/Media`

通过 GetCapabilities 动态获取,避免硬编码。

**3. GetProfiles**

```java
public List<OnvifProfile> getProfiles(String mediaXAddr, String user, String pass) 
        throws OnvifException {
    String body = "<trt:GetProfiles xmlns:trt=\"http://www.onvif.org/ver10/media/wsdl\" />";
    
    Document doc = soapClient.sendSoapRequest(mediaXAddr, user, pass, body);
    
    List<OnvifProfile> profiles = new ArrayList<>();
    NodeList nodes = doc.getElementsByTagNameNS("*", "Profiles");
    
    for (int i = 0; i < nodes.getLength(); i++) {
        Element elem = (Element) nodes.item(i);
        
        OnvifProfile profile = OnvifProfile.builder()
            .token(elem.getAttribute("token"))
            .name(getText(elem, "Name"))
            .videoSourceToken(getText(elem, "VideoSourceConfiguration", "SourceToken"))
            .videoEncodingToken(getText(elem, "VideoEncoderConfiguration", "token"))
            .encoding(getText(elem, "VideoEncoderConfiguration", "Encoding"))
            .width(getInt(elem, "VideoEncoderConfiguration", "Resolution", "Width"))
            .height(getInt(elem, "VideoEncoderConfiguration", "Resolution", "Height"))
            .build();
        
        profiles.add(profile);
    }
    
    return profiles;
}
```

**Profile 解析要点**:

1. **Token 提取**
    - `token` 属性是后续获取流地址的关键
2. **通道号提取**

```java
   // 从 SourceToken 提取通道号
   // 例如: VideoSource_1 -> 1
   private int extractChannel(String sourceToken) {
       if (sourceToken == null) return 1;
       Matcher m = Pattern.compile("\\d+").matcher(sourceToken);
       return m.find() ? Integer.parseInt(m.group()) : 1;
   }
```

1. **主/子码流判断**

```java
   private int detectSubtype(int width, int height, String name) {
       if (width >= 1280 || height >= 720) return 0; // 主码流
       if (name != null && name.toLowerCase().contains("sub")) return 1;
       return 1; // 默认子码流
   }
```

**4. GetStreamUri**

```java
public String getStreamUri(String mediaXAddr, String user, String pass, String profileToken) 
        throws OnvifException {
    String body = 
        "<trt:GetStreamUri xmlns:trt=\"http://www.onvif.org/ver10/media/wsdl\" " +
        "xmlns:tt=\"http://www.onvif.org/ver10/schema\">" +
        "<trt:StreamSetup>" +
        "<tt:Stream>RTP-Unicast</tt:Stream>" +
        "<tt:Transport><tt:Protocol>RTSP</tt:Protocol></tt:Transport>" +
        "</trt:StreamSetup>" +
        "<trt:ProfileToken>" + profileToken + "</trt:ProfileToken>" +
        "</trt:GetStreamUri>";
    
    Document doc = soapClient.sendSoapRequest(mediaXAddr, user, pass, body);
    
    String uri = getText(doc, "Uri");
    
    // 注入凭据
    return injectCredentials(uri, user, pass);
}

private String injectCredentials(String rtspUrl, String user, String pass) {
    try {
        URI uri = new URI(rtspUrl);
        String userInfo = user + ":" + pass;
        return new URI(
            uri.getScheme(),
            userInfo,
            uri.getHost(),
            uri.getPort(),
            uri.getPath(),
            uri.getQuery(),
            uri.getFragment()
        ).toString();
    } catch (URISyntaxException e) {
        throw new IllegalArgumentException("Invalid RTSP URL: " + rtspUrl, e);
    }
}
```

**为什么要注入凭据?**

大部分设备返回的 RTSP URI 不包含认证信息:
```
rtsp://10.0.1.20:554/Streaming/Channels/101
```

需要转换为:
```
rtsp://admin:password@10.0.1.20:554/Streaming/Channels/101
```

**5. GetSystemDateAndTime (心跳)**

```java
public void checkOnline(String ip, int port, String user, String pass) throws OnvifException {
    String url = String.format("http://%s:%d/onvif/device_service", ip, port);
    String body = "<tds:GetSystemDateAndTime xmlns:tds=\"http://www.onvif.org/ver10/device/wsdl\" />";
    
    // 超时设置为 3 秒
    Document doc = soapClient.sendSoapRequest(url, user, pass, body, 3000);
    
    // 能成功调用即表示在线,无需解析返回值
}
```

**为什么选择 GetSystemDateAndTime 作为心跳?**

1. **轻量级**:不涉及媒体资源,响应快
2. **稳定性高**:几乎所有设备都实现
3. **无副作用**:只读操作,不会改变设备状态

#### 4.5 厂商差异处理

**问题 1: Media XAddr 为空**

部分低端设备 GetCapabilities 返回空地址。

**解决方案**:

```java
String mediaXAddr = capabilities.getMediaXAddr();
if (StringUtils.isBlank(mediaXAddr)) {
    // 降级使用 Device Service 地址
    mediaXAddr = String.format("http://%s:%d/onvif/device_service", ip, port);
    log.warn("Media XAddr empty, fallback to device service for camera {}", cameraId);
}
```

**问题 2: ProfileToken 格式不一致**

- 海康:`Profile_1`
- 大华:`MediaProfile000`
- 宇视:`profile_1_h264`

**解决方案**:

```java
// 不依赖 token 格式,按索引或分辨率选择
OnvifProfile mainStream = profiles.stream()
    .filter(p -> p.getWidth() >= 1280)
    .findFirst()
    .orElse(profiles.get(0));
```

**问题 3: 时间窗口错误**

错误示例:
```
SOAP Fault: The security token could not be authenticated or authorized
```

**原因**:服务器时间与设备时间误差 > 5 秒

**解决方案**:

```java
@Scheduled(cron = "0 */30 * * * ?") // 每 30 分钟执行
public void syncServerTime() {
    try {
        ProcessBuilder pb = new ProcessBuilder("ntpdate", "ntp.aliyun.com");
        Process process = pb.start();
        process.waitFor(10, TimeUnit.SECONDS);
    } catch (Exception e) {
        log.error("NTP sync failed", e);
    }
}
```

#### 4.6 ONVIF 调用性能优化

**1. 连接池复用**

```java
@Configuration
public class OnvifHttpConfig {
    
    @Bean
    public CloseableHttpClient httpClient() {
        PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager();
        cm.setMaxTotal(200);
        cm.setDefaultMaxPerRoute(50);
        
        return HttpClients.custom()
            .setConnectionManager(cm)
            .setDefaultRequestConfig(
                RequestConfig.custom()
                    .setConnectTimeout(3000)
                    .setSocketTimeout(5000)
                    .build()
            )
            .build();
    }
}
```

**2. 设备信息缓存**

```java
@Cacheable(value = "device-info", key = "#cameraId", unless = "#result == null")
public DeviceInfo getDeviceInfo(Long cameraId) {
    CameraDevice device = cameraRepository.findById(cameraId)
        .orElseThrow(() -> new NotFoundException("Camera not found"));
    
    return onvifClient.getDeviceInformation(
        device.getIp(),
        device.getPort(),
        device.getUsername(),
        device.getPassword()
    );
}
```

**缓存策略**:

- TTL: 24 小时
- 失效条件:设备固件升级或手动清除

**3. 并发控制**

```java
private final Semaphore onvifSemaphore = new Semaphore(50);

public <T> T callOnvif(Supplier<T> supplier) throws Exception {
    onvifSemaphore.acquire();
    try {
        return supplier.get();
    } finally {
        onvifSemaphore.release();
    }
}
```

**原因**:避免同时调用大量设备导致网络拥塞。

------

### 5. MediaMTX 流媒体网关集成

#### 5.1 MediaMTX 核心概念

**Path (路径)**

Path 是 MediaMTX 中的核心抽象,代表一个独立的媒体流通道。每个 Path 包含:

- **Source**:流的来源 (RTSP URL、推流地址、publisher 等)
- **Readers**:消费该流的客户端连接
- **State**:路径状态 (idle、ready、publishing)

**按需拉流 (Source On Demand)**

```yaml
paths:
  cam_*:
    source: rtsp://admin:pass@10.0.1.20:554/Streaming/Channels/101
    sourceOnDemand: yes
    sourceOnDemandStartTimeout: 10s
    sourceOnDemandCloseAfter: 10s
```

**工作流程**:

1. 初始状态:Path 存在但未拉流
2. 客户端连接:触发 MediaMTX 拉取源流
3. 客户端断开:等待 `closeAfter` 时长后释放资源

**优势**:

- 节省带宽 (无观看时不拉流)
- 降低服务器负载
- 支持大规模路径管理

**按需转码 (Run On Demand)**

```yaml
paths:
  cam_h265_*:
    source: publisher
    runOnDemand: ffmpeg -i $SOURCE_URL -c:v libx264 -f rtsp rtsp://127.0.0.1:$RTSP_PORT/$MTX_PATH
    runOnDemandRestart: yes
```

**工作流程**:

1. 客户端连接触发命令执行
2. FFmpeg 进程启动并推流到 MediaMTX
3. 客户端断开后根据配置决定是否重启

**环境变量**:

- `$SOURCE_URL`:可用于引用上游地址
- `$RTSP_PORT`:MediaMTX RTSP 端口
- `$MTX_PATH`:当前路径名

#### 5.2 RESTful API 集成

MediaMTX 提供完整的 API 接口用于动态管理:

**API 端点**:

- `GET /v3/config/global/get`:获取全局配置
- `GET /v3/config/pathdefaults/get`:获取路径默认配置
- `POST /v3/config/paths/add/{name}`:添加路径
- `GET /v3/config/paths/get/{name}`:获取路径配置
- `POST /v3/config/paths/patch/{name}`:更新路径配置
- `POST /v3/config/paths/delete/{name}`:删除路径
- `GET /v3/config/paths/list`:列出所有路径

**路径配置结构**:

```json
{
  "name": "cam_10_0_1_20_ch1_main",
  "source": "rtsp://admin:pass@10.0.1.20:554/Streaming/Channels/101",
  "sourceProtocol": "tcp",
  "sourceOnDemand": true,
  "sourceOnDemandStartTimeout": "10s",
  "sourceOnDemandCloseAfter": "10s",
  
  "record": false,
  "recordPath": "",
  "recordFormat": "fmp4",
  "recordSegmentDuration": "10m",
  "recordDeleteAfter": "7d"
}
```

#### 5.3 路径命名规范

**命名模板**:
```
cam_{ip}_{channel}_{subtype}
```

**示例**:

- `cam_10_0_1_20_ch1_main`:10.0.1.20 设备第 1 通道主码流
- `cam_10_0_1_20_ch1_sub`:10.0.1.20 设备第 1 通道子码流
- `cam_10_0_1_21_ch2_main`:10.0.1.21 设备第 2 通道主码流

**命名规范优势**:

1. **可读性**:从路径名直接识别设备和通道
2. **唯一性**:全局唯一标识符
3. **模式匹配**:支持通配符配置

```yaml
   paths:
     cam_*_main:
       # 所有主码流共享配置
     cam_*_sub:
       # 所有子码流共享配置
```

#### 5.4 路径注册实现

**核心服务类**:

```java
@Service
@Slf4j
public class MediaPathService {
    
    @Value("${media.mtx.apiBaseUrl}")
    private String apiBaseUrl;
    
    private final RestTemplate restTemplate;
    
    /**
     * 注册直连路径
     */
    public void registerDirectPath(StreamPath path) {
        Map<String, Object> config = new HashMap<>();
        config.put("name", path.getPathName());
        config.put("source", path.getSourceUrl());
        config.put("sourceProtocol", "tcp");
        config.put("sourceOnDemand", true);
        config.put("sourceOnDemandStartTimeout", "10s");
        config.put("sourceOnDemandCloseAfter", "10s");
        
        addPath(path.getPathName(), config);
    }
    
    /**
     * 注册转码路径
     */
    public void registerTranscodePath(StreamPath path) {
        String ffmpegCmd = buildFfmpegCommand(path.getSourceUrl());
        
        Map<String, Object> config = new HashMap<>();
        config.put("name", path.getPathName());
        config.put("source", "publisher");
        config.put("runOnDemand", ffmpegCmd);
        config.put("runOnDemandRestart", true);
        config.put("runOnDemandStartTimeout", "10s");
        config.put("runOnDemandCloseAfter", "10s");
        
        addPath(path.getPathName(), config);
    }
    
    /**
     * 删除并重建路径 (确保配置完全生效)
     */
    public void updatePath(StreamPath path) {
        deletePath(path.getPathName());
        
        if (path.getNeedTranscode() == 1) {
            registerTranscodePath(path);
        } else {
            registerDirectPath(path);
        }
    }
    
    private void addPath(String pathName, Map<String, Object> config) {
        String url = apiBaseUrl + "/v3/config/paths/add/" + pathName;
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        HttpEntity<Map<String, Object>> request = new HttpEntity<>(config, headers);
        
        try {
            ResponseEntity<String> response = restTemplate.postForEntity(url, request, String.class);
            
            if (response.getStatusCode().is2xxSuccessful()) {
                log.info("Path registered: {}", pathName);
            } else {
                throw new MediaGatewayException("Failed to register path: " + response.getBody());
            }
        } catch (Exception e) {
            log.error("MediaMTX API error: {}", e.getMessage());
            throw new MediaGatewayException("Path registration failed", e);
        }
    }
    
    private void deletePath(String pathName) {
        String url = apiBaseUrl + "/v3/config/paths/delete/" + pathName;
        
        try {
            restTemplate.delete(url);
            log.info("Path deleted: {}", pathName);
        } catch (HttpClientErrorException.NotFound e) {
            // 路径不存在,忽略错误
        } catch (Exception e) {
            log.error("Failed to delete path {}: {}", pathName, e.getMessage());
        }
    }
    
    private String buildFfmpegCommand(String sourceUrl) {
        return String.format(
            "ffmpeg -hide_banner -loglevel warning " +
            "-rtsp_transport tcp " +
            "-i \"%s\" " +
            "-an " +
            "-c:v libx264 -preset veryfast -crf 23 " +
            "-tune zerolatency -pix_fmt yuv420p " +
            "-g 50 -keyint_min 50 -sc_threshold 0 " +
            "-x264-params repeat-headers=1 " +
            "-f rtsp -rtsp_transport tcp " +
            "\"rtsp://127.0.0.1:$RTSP_PORT/$MTX_PATH\"",
            sourceUrl
        );
    }
}
```

**为什么使用 Delete + Add 而非 Patch?**

1. **配置完整性**:Patch 可能保留旧配置片段,导致状态不一致
2. **立即生效**:Delete + Add 强制重建,确保新配置立刻生效
3. **语义清晰**:每次更新等价于发布新版本

**风险与缓解**:
- **短暂中断**:删除与添加之间有窗口期
- **缓解措施**:
    - 在低峰期批量变更
    - 添加失败时回滚到旧配置
    - 关键路径增加重试机制

#### 5.5 播放地址生成

**RTSP 地址**:

```
rtsp://{MediaMTX_IP}:{RTSP_Port}/{path_name}
```

示例:
```
rtsp://10.0.10.1:8554/cam_10_0_1_20_ch1_main
```

**HLS 地址**:
```
http://{MediaMTX_IP}:{HLS_Port}/{path_name}/index.m3u8
```

示例:
```
http://10.0.10.1:8888/cam_10_0_1_20_ch1_main/index.m3u8
```

**WebRTC 地址**:
```
http://{MediaMTX_IP}:{WebRTC_Port}/{path_name}
```

示例:
```
http://10.0.10.1:8889/cam_10_0_1_20_ch1_main
```

**播放器选择建议**:

| 场景              | 协议   | 延迟   | 兼容性      | 推荐播放器 |
| ----------------- | ------ | ------ | ----------- | ---------- |
| PC 浏览器实时预览 | WebRTC | 500ms  | Chrome/Edge | WebRTC.js  |
| 移动端 H5         | HLS    | 3-5s   | iOS/Android | video.js   |
| 客户端应用        | RTSP   | 1-2s   | 需原生支持  | VLC/ffplay |
| 录像回放          | HLS    | 不关键 | 全平台      | video.js   |

------

### 6. FFmpeg 编解码治理

#### 6.1 编码探测策略

**为什么需要探测?**

1. **浏览器兼容性**:Safari 不支持 H.265,Chrome 90+ 才支持
2. **成本控制**:H.264 可直连,H.265 需转码 (CPU 密集)
3. **质量保障**:探测失败的流不应接入系统

**探测流程**:

```java
@Service
@Slf4j
public class CodecProbeService {
    
    @Value("${codec.probe.ffprobe-bin:ffprobe}")
    private String ffprobeBin;
    
    @Value("${codec.probe.timeout-ms:3000}")
    private int timeoutMs;
    
    private final Semaphore probeSemaphore = new Semaphore(8);
    
    public CodecInfo probe(String rtspUrl) {
        try {
            probeSemaphore.acquire();
            return doProbe(rtspUrl);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return CodecInfo.unknown();
        } finally {
            probeSemaphore.release();
        }
    }
    
    private CodecInfo doProbe(String rtspUrl) {
        List<String> command = Arrays.asList(
            ffprobeBin,
            "-v", "error",
            "-rtsp_transport", "tcp",
            "-analyzeduration", "1000000",
            "-probesize", "32768",
            "-select_streams", "v:0",
            "-show_entries", "stream=codec_name,width,height,avg_frame_rate",
            "-of", "json",
            rtspUrl
        );
        
        ProcessBuilder pb = new ProcessBuilder(command);
        pb.redirectErrorStream(true);
        
        try {
            Process process = pb.start();
            boolean finished = process.waitFor(timeoutMs, TimeUnit.MILLISECONDS);
            
            if (!finished) {
                process.destroyForcibly();
                log.warn("ffprobe timeout for {}", maskUrl(rtspUrl));
                return CodecInfo.unknown();
            }
            
            if (process.exitValue() != 0) {
                log.warn("ffprobe failed for {}", maskUrl(rtspUrl));
                return CodecInfo.unknown();
            }
            
            String output = IOUtils.toString(process.getInputStream(), StandardCharsets.UTF_8);
            return parseProbeOutput(output);
            
        } catch (Exception e) {
            log.error("ffprobe error for {}: {}", maskUrl(rtspUrl), e.getMessage());
            return CodecInfo.unknown();
        }
    }
    
    private CodecInfo parseProbeOutput(String json) {
        try {
            JSONObject obj = JSON.parseObject(json);
            JSONArray streams = obj.getJSONArray("streams");
            
            if (streams == null || streams.isEmpty()) {
                return CodecInfo.unknown();
            }
            
            JSONObject stream = streams.getJSONObject(0);
            
            String codecName = stream.getString("codec_name");
            int width = stream.getIntValue("width");
            int height = stream.getIntValue("height");
            String frameRate = stream.getString("avg_frame_rate");
            
            return CodecInfo.builder()
                .codec(normalizeCodec(codecName))
                .width(width)
                .height(height)
                .frameRate(parseFrameRate(frameRate))
                .build();
                
        } catch (Exception e) {
            log.error("Failed to parse ffprobe output", e);
            return CodecInfo.unknown();
        }
    }
    
    private String normalizeCodec(String codecName) {
        if (codecName == null) return "UNKNOWN";
        
        String lower = codecName.toLowerCase();
        if (lower.contains("h264") || lower.equals("avc")) return "H264";
        if (lower.contains("h265") || lower.equals("hevc")) return "H265";
        if (lower.contains("mjpeg")) return "MJPEG";
        
        return "UNKNOWN";
    }
    
    private double parseFrameRate(String frameRate) {
        if (frameRate == null || frameRate.isEmpty()) return 0.0;
        
        try {
            if (frameRate.contains("/")) {
                String[] parts = frameRate.split("/");
                double num = Double.parseDouble(parts[0]);
                double den = Double.parseDouble(parts[1]);
                return den == 0 ? 0 : num / den;
            }
            return Double.parseDouble(frameRate);
        } catch (Exception e) {
            return 0.0;
        }
    }
    
    private String maskUrl(String url) {
        return url.replaceAll("://[^@]+@", "://***:***@");
    }
}
```

**并发控制为什么必要?**

批量接入 500 路相机时,如果不限制并发:

- CPU 负载瞬间飙升至 100%
- 磁盘 I/O 饱和 (ffprobe 需要写临时文件)
- 导致正常业务请求超时

推荐并发数:

- 4 核 8G:并发 4-8
- 8 核 16G:并发 8-16
- 16 核 32G:并发 16-32

#### 6.2 转码决策引擎

**决策矩阵**:

| 编码格式 | 浏览器兼容性 | 决策     | 备注                      |
| -------- | ------------ | -------- | ------------------------- |
| H264     | ✅ 全兼容     | 直连     | 无需转码                  |
| H265     | ⚠️ 部分兼容   | 转码     | Chrome 90+, Safari 不支持 |
| MJPEG    | ⚠️ 兼容但低效 | 转码     | 带宽占用高                |
| UNKNOWN  | ❌ 未知       | 保守转码 | 探测失败兜底              |

**实现代码**:

```java
@Service
public class CodecDecisionService {
    
    @Value("${codec.transcode.enabled:true}")
    private boolean transcodeEnabled;
    
    @Value("${codec.transcode.assume-h265-when-unknown:true}")
    private boolean assumeH265WhenUnknown;
    
    public boolean needTranscode(String codec) {
        if (!transcodeEnabled) {
            return false;
        }
        
        if (codec == null || "UNKNOWN".equals(codec)) {
            return assumeH265WhenUnknown;
        }
        
        return "H265".equals(codec) || "HEVC".equals(codec) || "MJPEG".equals(codec);
    }
    
    public TranscodeStrategy selectStrategy(CodecInfo info) {
        if (!needTranscode(info.getCodec())) {
            return TranscodeStrategy.DIRECT;
        }
        
        // 根据分辨率选择转码参数
        if (info.getWidth() >= 1920 || info.getHeight() >= 1080) {
            return TranscodeStrategy.HIGH_QUALITY;
        } else if (info.getWidth() >= 1280 || info.getHeight() >= 720) {
            return TranscodeStrategy.MEDIUM_QUALITY;
        } else {
            return TranscodeStrategy.LOW_QUALITY;
        }
    }
}

public enum TranscodeStrategy {
    DIRECT(null, null, null),
    HIGH_QUALITY("veryfast", "23", "50"),
    MEDIUM_QUALITY("faster", "25", "60"),
    LOW_QUALITY("fast", "28", "90");
    
    private final String preset;
    private final String crf;
    private final String gop;
    
    // constructor and getters
}
```

#### 6.3 转码命令构建

**基础转码命令**:

```java
public class FfmpegCommandBuilder {
    
    public String buildTranscodeCommand(String sourceUrl, TranscodeStrategy strategy) {
        StringBuilder cmd = new StringBuilder();
        
        cmd.append("ffmpeg -hide_banner -loglevel warning ");
        cmd.append("-rtsp_transport tcp ");
        cmd.append("-stimeout 5000000 ");
        cmd.append("-probesize 5000000 ");
        cmd.append("-analyzeduration 5000000 ");
        cmd.append("-i \"").append(sourceUrl).append("\" ");
        
        // 禁用音频
        cmd.append("-an ");
        
        // 视频编码参数
        cmd.append("-c:v libx264 ");
        cmd.append("-preset ").append(strategy.getPreset()).append(" ");
        cmd.append("-crf ").append(strategy.getCrf()).append(" ");
        cmd.append("-tune zerolatency ");
        cmd.append("-pix_fmt yuv420p ");
        cmd.append("-g ").append(strategy.getGop()).append(" ");
        cmd.append("-keyint_min ").append(strategy.getGop()).append(" ");
        cmd.append("-sc_threshold 0 ");
        cmd.append("-x264-params repeat-headers=1 ");
        
        // 输出格式
        cmd.append("-f rtsp -rtsp_transport tcp ");
        cmd.append("\"rtsp://127.0.0.1:$RTSP_PORT/$MTX_PATH\"");
        
        return cmd.toString();
    }
}
```

**硬件加速版本 (NVENC)**:

```java
public String buildNvencCommand(String sourceUrl) {
    StringBuilder cmd = new StringBuilder();
    
    cmd.append("ffmpeg -hide_banner -loglevel warning ");
    cmd.append("-hwaccel cuda -hwaccel_output_format cuda ");
    cmd.append("-rtsp_transport tcp ");
    cmd.append("-i \"").append(sourceUrl).append("\" ");
    cmd.append("-an ");
    cmd.append("-c:v h264_nvenc ");
    cmd.append("-preset p4 ");
    cmd.append("-b:v 3000k ");
    cmd.append("-g 50 ");
    cmd.append("-f rtsp -rtsp_transport tcp ");
    cmd.append("\"rtsp://127.0.0.1:$RTSP_PORT/$MTX_PATH\"");
    
    return cmd.toString();
}
```

**硬件加速检测**:

```java
public boolean isNvencAvailable() {
    try {
        ProcessBuilder pb = new ProcessBuilder("ffmpeg", "-encoders");
        Process process = pb.start();
        
        String output = IOUtils.toString(process.getInputStream(), StandardCharsets.UTF_8);
        return output.contains("h264_nvenc");
        
    } catch (Exception e) {
        return false;
    }
}
```

**参数调优指南**:

| 参数      | 推荐值      | 说明         | 影响           |
| --------- | ----------- | ------------ | -------------- |
| `-preset` | veryfast    | 编码速度预设 | 速度 ↑ 质量 ↓  |
| `-crf`    | 23          | 恒定质量因子 | 值越小质量越高 |
| `-tune`   | zerolatency | 低延迟优化   | 减少缓冲延迟   |
| `-g`      | 50          | GOP 大小     | 影响跳转精度   |
| `-b:v`    | 3000k       | 码率         | 带宽与质量平衡 |

---

### 7. 相机接入完整流程

#### 7.1 接入时序图
```
[前端] → [接口层] → [业务层] → [ONVIF层] → [设备]
   │         │          │           │
   │         │          │           └─→ GetDeviceInformation
   │         │          │           └─→ GetCapabilities
   │         │          │           └─→ GetProfiles
   │         │          │           └─→ GetStreamUri (per profile)
   │         │          │
   │         │          └─→ [数据层] 保存设备主档
   │         │          └─→ [异步任务] 流同步
   │         │                      │
   │         │                      └─→ FFprobe 探测编码
   │         │                      └─→ 保存流路径
   │         │                      └─→ MediaMTX 注册路径
   │         │
   │         └─→ 返回接入结果
```

#### 7.2 接入请求模型

```java
@Data
public class CameraAddRequest {
    @NotBlank(message = "IP不能为空")
    private String ip;
    
    @Min(value = 1, message = "端口范围 1-65535")
    @Max(value = 65535, message = "端口范围 1-65535")
    private Integer port = 80;
    
    @NotBlank(message = "用户名不能为空")
    private String username;
    
    @NotBlank(message = "密码不能为空")
    private String password;
    
    private String cameraName;
    private Long groupId;
    
    /**
     * 0: 标准 ONVIF 流程
     * 1: 厂商兜底模式 (跳过 ONVIF,使用固定规则)
     */
    private Integer skipOnvif = 0;
    
    /**
     * 厂商类型 (skipOnvif=1 时有效)
     * 支持: HIKVISION, DAHUA, UNIVIEW
     */
    private String vendorType;
}
```

#### 7.3 接入服务实现

```java
@Service
@Slf4j
public class CameraOnboardingService {
    
    @Resource
    private CameraDeviceRepository deviceRepository;
    
    @Resource
    private OnvifManager onvifManager;
    
    @Resource
    private StreamPathService streamPathService;
    
    @Resource
    private CameraGroupService groupService;
    
    @Transactional(rollbackFor = Exception.class)
    public CameraDevice addCamera(CameraAddRequest request) {
        // 1. 重复性校验
        if (deviceRepository.existsByIpAndIsDeleted(request.getIp(), 0)) {
            throw new BusinessException("设备已存在: " + request.getIp());
        }
        
        // 2. 构建设备实体
        CameraDevice device = new CameraDevice();
        BeanUtils.copyProperties(request, device);
        
        // 设置默认名称
        if (StringUtils.isBlank(device.getCameraName())) {
            device.setCameraName(device.getIp());
        }
        
        // 3. ONVIF 信息获取
        if (request.getSkipOnvif() == 0) {
            try {
                OnvifDeviceDetail detail = onvifManager.getDeviceInformation(
                    device.getIp(),
                    device.getPort(),
                    device.getUsername(),
                    device.getPassword()
                );
                
                device.setManufacturer(detail.getManufacturer());
                device.setModel(detail.getModel());
                device.setSerialNumber(detail.getSerialNumber());
                device.setFirmwareVersion(detail.getFirmwareVersion());
                
            } catch (OnvifException e) {
                log.error("ONVIF failed for {}, fallback to basic mode", request.getIp(), e);
                device.setManufacturer("UNKNOWN");
                device.setModel("UNKNOWN");
            }
        } else {
            // 厂商兜底模式
            device.setManufacturer(request.getVendorType());
            device.setModel("Generic");
        }
        
        // 4. 设置初始状态
        device.setCameraStatus(1);
        device.setLastOnlineTime(LocalDateTime.now());
        
        // 5. 解析分组
        if (request.getGroupId() == null) {
            device.setGroupId(groupService.getDefaultGroupId());
        }
        
        // 6. 保存设备
        deviceRepository.save(device);
        
        // 7. 异步同步流路径
        CompletableFuture.runAsync(() -> {
            try {
                streamPathService.syncStreamPaths(device, request);
            } catch (Exception e) {
                log.error("Stream sync failed for camera {}", device.getId(), e);
            }
        });
        
        return device;
    }
}
```

**事务边界设计**:

1. **同步部分** (在事务内):
    - 设备主档写入
    - 基础验证
2. **异步部分** (事务外):
    - 流路径同步
    - MediaMTX 注册

**为什么异步?**

- ONVIF 调用可能超时 (3-5秒)
- FFprobe 探测耗时 (2-3秒/路)
- 避免接口长时间阻塞

#### 7.4 流同步服务

**标准 ONVIF 模式**:

```java
@Service
@Slf4j
public class StreamPathService {
    
    @Resource
    private StreamPathRepository pathRepository;
    
    @Resource
    private OnvifManager onvifManager;
    
    @Resource
    private CodecProbeService codecProbeService;
    
    @Resource
    private CodecDecisionService codecDecisionService;
    
    @Resource
    private MediaPathService mediaPathService;
    
    @Transactional(rollbackFor = Exception.class)
    public void syncStreamPaths(CameraDevice device, CameraAddRequest request) {
        if (request.getSkipOnvif() == 1) {
            syncStreamPathsVendorFallback(device, request);
            return;
        }
        
        // 1. 获取 Profiles
        List<OnvifProfile> profiles = onvifManager.getProfiles(
            device.getIp(),
            device.getPort(),
            device.getUsername(),
            device.getPassword()
        );
        
        if (profiles.isEmpty()) {
            throw new BusinessException("No profiles found for camera: " + device.getIp());
        }
        
        // 2. 删除旧路径
        pathRepository.deleteAllByCameraId(device.getId());
        
        // 3. 处理每个 Profile
        for (OnvifProfile profile : profiles) {
            try {
                processProfile(device, profile);
            } catch (Exception e) {
                log.error("Failed to process profile {} for camera {}", 
                    profile.getToken(), device.getId(), e);
            }
        }
    }
    
    private void processProfile(CameraDevice device, OnvifProfile profile) {
        // 1. 获取 RTSP URI
        String rtspUri = onvifManager.getStreamUri(
            device.getIp(),
            device.getPort(),
            device.getUsername(),
            device.getPassword(),
            profile.getToken()
        );
        
        if (StringUtils.isBlank(rtspUri)) {
            log.warn("Empty RTSP URI for profile {}", profile.getToken());
            return;
        }
        
        // 2. 注入凭据
        String sourceUrl = injectCredentials(rtspUri, device.getUsername(), device.getPassword());
        
        // 3. 探测编码
        CodecInfo codecInfo = codecProbeService.probe(sourceUrl);
        String codec = codecInfo.getCodec();
        boolean needTranscode = codecDecisionService.needTranscode(codec);
        
        // 4. 构建路径名
        int channel = extractChannel(profile.getVideoSourceToken());
        int subtype = detectSubtype(profile.getWidth(), profile.getName());
        String pathName = buildPathName(device.getIp(), channel, subtype);
        
        // 5. 保存路径记录
        StreamPath path = StreamPath.builder()
            .cameraId(device.getId())
            .pathName(pathName)
            .sourceUrl(sourceUrl)
            .profileToken(profile.getToken())
            .profileName(profile.getName())
            .videoEncoding(profile.getEncoding())
            .videoCodec(codec)
            .resolution(profile.getWidth() + "x" + profile.getHeight())
            .subtype(subtype)
            .channel(channel)
            .needTranscode(needTranscode ? 1 : 0)
            .enabled(1)
            .status(1)
            .build();
        
        pathRepository.save(path);
        
        // 6. 注册到 MediaMTX
        try {
            mediaPathService.updatePath(path);
            log.info("Path registered: {}", pathName);
        } catch (Exception e) {
            log.error("MediaMTX registration failed for {}", pathName, e);
            path.setStatus(0);
            pathRepository.updateById(path);
        }
    }
    
    private String buildPathName(String ip, int channel, int subtype) {
        String ipNormalized = ip.replace(".", "_");
        String subtypeStr = (subtype == 0) ? "main" : "sub";
        return String.format("cam_%s_ch%d_%s", ipNormalized, channel, subtypeStr);
    }
    
    private int extractChannel(String sourceToken) {
        if (sourceToken == null) return 1;
        
        Matcher m = Pattern.compile("\\d+").matcher(sourceToken);
        return m.find() ? Integer.parseInt(m.group()) : 1;
    }
    
    private int detectSubtype(int width, String name) {
        // 主码流判断
        if (width >= 1280) return 0;
        
        // 名称包含 sub/stream2 等关键字
        if (name != null) {
            String lower = name.toLowerCase();
            if (lower.contains("sub") || lower.contains("stream2")) {
                return 1;
            }
        }
        
        // 默认子码流
        return 1;
    }
    
    private String injectCredentials(String rtspUrl, String user, String pass) {
        try {
            URI uri = new URI(rtspUrl);
            String userInfo = URLEncoder.encode(user, "UTF-8") + ":" + 
                              URLEncoder.encode(pass, "UTF-8");
            
            return new URI(
                uri.getScheme(),
                userInfo,
                uri.getHost(),
                uri.getPort(),
                uri.getPath(),
                uri.getQuery(),
                uri.getFragment()
            ).toString();
        } catch (Exception e) {
            throw new IllegalArgumentException("Invalid RTSP URL: " + rtspUrl, e);
        }
    }
}
```

**厂商兜底模式**:

```java
private void syncStreamPathsVendorFallback(CameraDevice device, CameraAddRequest request) {
    String vendor = request.getVendorType();
    
    if (!"HIKVISION".equalsIgnoreCase(vendor)) {
        throw new BusinessException("Unsupported vendor fallback: " + vendor);
    }
    
    // 海康固定规则
    List<String> rtspTemplates = Arrays.asList(
        "rtsp://{ip}:554/Streaming/Channels/101",  // 主码流
        "rtsp://{ip}:554/Streaming/Channels/102"   // 子码流
    );
    
    pathRepository.deleteAllByCameraId(device.getId());
    
    for (int i = 0; i < rtspTemplates.size(); i++) {
        String template = rtspTemplates.get(i);
        String rtspUrl = template.replace("{ip}", device.getIp());
        String sourceUrl = injectCredentials(rtspUrl, device.getUsername(), device.getPassword());
        
        CodecInfo codecInfo = codecProbeService.probe(sourceUrl);
        String codec = codecInfo.getCodec();
        boolean needTranscode = codecDecisionService.needTranscode(codec);
        
        int subtype = i; // 0=main, 1=sub
        String pathName = buildPathName(device.getIp(), 1, subtype);
        
        StreamPath path = StreamPath.builder()
            .cameraId(device.getId())
            .pathName(pathName)
            .sourceUrl(sourceUrl)
            .videoCodec(codec)
            .subtype(subtype)
            .channel(1)
            .needTranscode(needTranscode ? 1 : 0)
            .enabled(1)
            .status(1)
            .build();
        
        pathRepository.save(path);
        mediaPathService.updatePath(path);
    }
}
```

#### 7.5 接入失败处理

**失败分类**:

1. **ONVIF 连接失败**
    - 原因:网络不通、端口错误、服务未启动
    - 处理:返回明确错误信息,不创建设备记录
2. **认证失败**
    - 原因:用户名密码错误、权限不足
    - 处理:提示用户检查凭据
3. **能力不足**
    - 原因:设备不支持 Media Service
    - 处理:降级到厂商兜底模式
4. **流探测失败**
    - 原因:RTSP 不可达、编码异常
    - 处理:标记路径状态为失败,允许后续重试

**错误示例**:

```json
{
  "code": 400,
  "message": "设备接入失败",
  "details": {
    "step": "ONVIF_DEVICE_INFO",
    "error": "Connection timeout",
    "suggestion": "请检查设备网络连接和 ONVIF 服务是否启动"
  }
}
```

------

### 8. 设备状态巡检与事件闭环

#### 8.1 在线巡检机制

**巡检策略**:

```java
@Component
@Slf4j
public class CameraHealthCheckTask {
    
    @Resource
    private CameraDeviceRepository deviceRepository;
    
    @Resource
    private OnvifManager onvifManager;
    
    @Resource
    private CameraOfflineEventService offlineEventService;
    
    @Value("${camera.health.check-interval-ms:30000}")
    private long checkInterval;
    
    @Scheduled(fixedDelayString = "${camera.health.check-interval-ms:30000}")
    public void checkAllDevices() {
        List<CameraDevice> devices = deviceRepository.findAllActive();
        
        log.info("Starting health check for {} devices", devices.size());
        
        for (CameraDevice device : devices) {
            try {
                checkSingleDevice(device);
            } catch (Exception e) {
                log.error("Health check failed for device {}", device.getId(), e);
            }
        }
    }
    
    private void checkSingleDevice(CameraDevice device) {
        boolean online = isOnline(device);
        LocalDateTime now = LocalDateTime.now();
        
        if (online) {
            handleOnline(device, now);
        } else {
            handleOffline(device, now);
        }
    }
    
    private boolean isOnline(CameraDevice device) {
        try {
            onvifManager.getSystemDateAndTime(
                device.getIp(),
                device.getPort(),
                device.getUsername(),
                device.getPassword()
            );
            return true;
        } catch (Exception e) {
            log.debug("Device {} offline: {}", device.getId(), e.getMessage());
            return false;
        }
    }
    
    @Transactional(rollbackFor = Exception.class)
    protected void handleOnline(CameraDevice device, LocalDateTime checkTime) {
        // 状态变化:离线 -> 在线
        if (device.getCameraStatus() == 0) {
            device.setCameraStatus(1);
            device.setLastOnlineTime(checkTime);
            deviceRepository.updateById(device);
            
            // 闭环离线事件
            offlineEventService.resolveEvent(device.getId(), checkTime);
            
            log.info("Device {} back online", device.getId());
        } else {
            // 刷新在线时间
            device.setLastOnlineTime(checkTime);
            deviceRepository.updateById(device);
        }
    }
    
    @Transactional(rollbackFor = Exception.class)
    protected void handleOffline(CameraDevice device, LocalDateTime checkTime) {
        // 状态变化:在线 -> 离线
        if (device.getCameraStatus() == 1) {
            device.setCameraStatus(0);
            deviceRepository.updateById(device);
            
            // 创建离线事件
            offlineEventService.createEvent(device, checkTime);
            
            log.warn("Device {} went offline", device.getId());
        } else {
            // 更新离线事件
            offlineEventService.updateEvent(device.getId(), checkTime);
        }
    }
}
```

**为什么必须异常隔离?**

如果单台设备异常导致整批巡检中断:

- 其他设备状态陈旧
- 离线事件无法及时创建
- 运维告警失效

#### 8.2 离线事件管理

```java
@Service
@Slf4j
public class CameraOfflineEventService {
    
    @Resource
    private CameraOfflineEventRepository eventRepository;
    
    @Transactional(rollbackFor = Exception.class)
    public void createEvent(CameraDevice device, LocalDateTime startTime) {
        CameraOfflineEvent event = CameraOfflineEvent.builder()
            .deviceId(device.getId())
            .deviceIp(device.getIp())
            .groupId(device.getGroupId())
            .startTime(startTime)
            .lastCheckTime(startTime)
            .isResolved(0)
            .alarmStatus(0)
            .build();
        
        eventRepository.save(event);
        
        log.info("Offline event created for device {}", device.getId());
    }
    
    @Transactional(rollbackFor = Exception.class)
    public void updateEvent(Long deviceId, LocalDateTime checkTime) {
        CameraOfflineEvent event = eventRepository.findLatestByDeviceId(deviceId);
        
        if (event == null || event.getIsResolved() == 1) {
            // 事件已闭环或不存在,不应到达此分支
            log.warn("No active offline event for device {}", deviceId);
            return;
        }
        
        event.setLastCheckTime(checkTime);
        
        long duration = Duration.between(event.getStartTime(), checkTime).getSeconds();
        event.setDuration(duration);
        
        eventRepository.updateById(event);
    }
    
    @Transactional(rollbackFor = Exception.class)
    public void resolveEvent(Long deviceId, LocalDateTime endTime) {
        CameraOfflineEvent event = eventRepository.findLatestByDeviceId(deviceId);
        
        if (event == null || event.getIsResolved() == 1) {
            return;
        }
        
        event.setEndTime(endTime);
        event.setIsResolved(1);
        
        long duration = Duration.between(event.getStartTime(), endTime).getSeconds();
        event.setDuration(duration);
        
        eventRepository.updateById(event);
        
        log.info("Offline event resolved for device {}, duration: {}s", deviceId, duration);
    }
    
    /**
     * 查询当前未恢复的离线设备
     */
    public List<CameraOfflineEvent> listActiveEvents() {
        return eventRepository.findByIsResolved(0);
    }
    
    /**
     * 按时间范围查询离线历史
     */
    public List<CameraOfflineEvent> queryHistory(LocalDateTime start, LocalDateTime end) {
        return eventRepository.findByStartTimeBetween(start, end);
    }
}
```

**事件状态机**:

```
[设备在线] --检测离线--> [创建事件] (is_resolved=0)
     │                        │
     │                        ├--持续离线--> [更新 duration]
     │                        │
     │                        └--恢复在线--> [闭环事件] (is_resolved=1, end_time)
     │
     └--始终在线--> [无事件]
```
**离线率统计示例**:

```java
public OfflineStatistics calculateOfflineRate(LocalDateTime start, LocalDateTime end) {
    List<CameraOfflineEvent> events = queryHistory(start, end);
    
    long totalDuration = events.stream()
        .mapToLong(CameraOfflineEvent::getDuration)
        .sum();
    
    long windowDuration = Duration.between(start, end).getSeconds();
    double offlineRate = (double) totalDuration / windowDuration * 100;
    
    return OfflineStatistics.builder()
        .eventCount(events.size())
        .totalOfflineDuration(totalDuration)
        .offlineRate(offlineRate)
        .build();
}

```

---

## 第二部分:录像存储系统

### 9. 录像系统架构设计

#### 9.1 录像链路的核心挑战

**问题 1:策略落不下去**

现象:
- 数据库中录像计划显示已启用
- MediaMTX 路径配置未生效或参数错误
- 文件系统无录像文件产生

根因:
- 配置下发与数据库操作不在同一事务
- 下发失败未回滚数据库状态

**问题 2:存储不可治理**

现象:
- 不知道当前写入哪个盘
- 磁盘满后录像中断,无自动切换
- 跨盘迁移时路径混乱

根因:
- 缺少存储卷抽象
- 容量监控与切换策略分离

**问题 3:文件可写不可查**

现象:
- 物理文件存在于 `/recordings` 目录
- 回放接口查询为空
- 必须通过目录遍历才能找到文件

根因:
- 缺少文件索引
- 录像与检索解耦不彻底

#### 9.2 录像系统分层设计
```
┌─────────────────────────────────────────┐
│          策略层 (Policy Layer)           │
│  - 录像计划管理                          │
│  - 参数归一化                            │
│  - 调度决策                              │
└──────────────┬──────────────────────────┘
               │
┌──────────────┴──────────────────────────┐
│         媒体层 (Media Layer)             │
│  - MediaMTX 路径配置                     │
│  - 切片参数控制                          │
│  - 生命周期管理                          │
└──────────────┬──────────────────────────┘
               │
┌──────────────┴──────────────────────────┐
│        存储层 (Storage Layer)            │
│  - 存储卷管理                            │
│  - 容量监控                              │
│  - 写入路径分配                          │
└──────────────┬──────────────────────────┘
               │
┌──────────────┴──────────────────────────┐
│         索引层 (Index Layer)             │
│  - 文件发现扫描                          │
│  - 元信息提取                            │
│  - 检索优化                              │
└─────────────────────────────────────────┘
```

#### 9.3 录像时序图
```
[用户] → [录像接口] → [计划服务] → [存储卷服务]
                        │              │
                        │              └→ 查询可写卷
                        │              └→ 返回 rootPath
                        │
                        ├→ 构建录像路径模板
                        ├→ [MediaMTX 客户端]
                        │      │
                        │      ├→ DELETE /paths/{pathName}
                        │      └→ POST /paths/add/{pathName}
                        │              (record=true, recordPath=...)
                        │
                        └→ [数据库] 保存录像计划
                        
[定时任务] → [文件索引器] → 扫描 rootPath 目录
                             │
                             ├→ 解析文件名 (时间戳提取)
                             ├→ 计算文件大小
                             └→ [数据库] upsert recording_file
```

------

### 10. 存储卷治理与容量管理

#### 10.1 存储卷表设计

```sql
DROP TABLE IF EXISTS `storage_volume`;
CREATE TABLE `storage_volume` (
  `id`                BIGINT NOT NULL AUTO_INCREMENT,
  `volume_code`       VARCHAR(64)  NOT NULL COMMENT '卷唯一编码',
  `name`              VARCHAR(64)  NOT NULL COMMENT '卷名称',
  `root_path`         VARCHAR(255) NOT NULL COMMENT '挂载路径',
  
  -- 状态字段
  `status`            TINYINT NOT NULL DEFAULT 1 COMMENT '1读写 2只读 0离线',
  `capacity_total`    BIGINT DEFAULT 0 COMMENT '总容量(Byte)',
  `capacity_used`     BIGINT DEFAULT 0 COMMENT '已用容量(Byte)',
  
  -- 水位线配置
  `watermark_high`    INT DEFAULT 90 COMMENT '高水位(%)',
  `watermark_low`     INT DEFAULT 75 COMMENT '低水位(%)',
  
  -- 优先级
  `priority`          INT NOT NULL DEFAULT 0 COMMENT '优先级(越大越优先)',
  `is_full`           TINYINT NOT NULL DEFAULT 0 COMMENT '1已满 0未满',
  
  `remark`            VARCHAR(255) DEFAULT NULL,
  `create_time`       DATETIME DEFAULT CURRENT_TIMESTAMP,
  `update_time`       DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_volume_code` (`volume_code`),
  UNIQUE KEY `uk_root_path` (`root_path`),
  KEY `idx_status_priority` (`status`, `priority`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='存储卷表';
```

**设计要点**:

1. **双水位线机制**
    - `watermark_high`:触发切卷阈值 (例如 90%)
    - `watermark_low`:恢复写入阈值 (例如 75%)
    - 避免频繁切换导致抖动
2. **优先级调度**
    - 多个可写卷时,优先选择 `priority` 高的
    - 支持手动指定高性能存储
3. **路径唯一性**
    - `uk_root_path`:防止重复挂载同一目录

#### 10.2 容量监控服务

```java
@Service
@Slf4j
public class StorageVolumeService {
    
    @Resource
    private StorageVolumeRepository volumeRepository;
    
    @Scheduled(fixedDelayString = "${recording.storage.refresh-interval-ms:15000}")
    public void refreshAllVolumes() {
        List<StorageVolume> volumes = volumeRepository.findAll();
        
        for (StorageVolume volume : volumes) {
            try {
                refreshCapacity(volume);
            } catch (Exception e) {
                log.error("Failed to refresh volume {}", volume.getId(), e);
            }
        }
    }
    
    @Transactional(rollbackFor = Exception.class)
    public void refreshCapacity(StorageVolume volume) {
        File root = new File(volume.getRootPath());
        
        // 路径校验
        if (!root.exists() || !root.isDirectory()) {
            volume.setStatus(0); // 离线
            volume.setCapacityTotal(0L);
            volume.setCapacityUsed(0L);
            volumeRepository.updateById(volume);
            return;
        }
        
        // 容量获取
        long total = root.getTotalSpace();
        long free = root.getFreeSpace();
        long used = total - free;
        
        volume.setCapacityTotal(total);
        volume.setCapacityUsed(used);
        
        // 使用率计算
        int usage = (total == 0) ? 0 : (int) (used * 100 / total);
        
        // 水位线判断
        if (usage >= volume.getWatermarkHigh()) {
            volume.setIsFull(1);
            volume.setStatus(2); // 只读
            log.warn("Volume {} reached high watermark: {}%", volume.getId(), usage);
            
        } else if (usage <= volume.getWatermarkLow()) {
            volume.setIsFull(0);
            if (volume.getStatus() != 0) {
                volume.setStatus(1); // 恢复读写
                log.info("Volume {} recovered to writable: {}%", volume.getId(), usage);
            }
        }
        
        volumeRepository.updateById(volume);
    }
    
    /**
     * 挑选可写卷
     */
    public Optional<StorageVolume> pickWritableVolume() {
        return volumeRepository.findByStatusAndIsFullOrderByPriorityDesc(1, 0)
            .stream()
            .min(Comparator.comparingLong(StorageVolume::getCapacityUsed));
    }
}
```

**容量刷新频率**:

- 推荐:15-30 秒
- 过高:文件系统 I/O 压力
- 过低:水位线切换不及时

#### 10.3 存储卷添加

```java
@Service
public class StorageVolumeService {
    
    @Transactional(rollbackFor = Exception.class)
    public StorageVolume addVolume(AddVolumeRequest request) {
        // 1. 路径校验
        File file = new File(request.getRootPath());
        if (!file.exists() || !file.isDirectory()) {
            throw new BusinessException("路径不存在或不是目录: " + request.getRootPath());
        }
        
        // 2. 重复性校验
        if (volumeRepository.existsByRootPath(request.getRootPath())) {
            throw new BusinessException("路径已被其他卷使用: " + request.getRootPath());
        }
        
        // 3. 构建卷实体
        StorageVolume volume = StorageVolume.builder()
            .volumeCode(request.getVolumeCode())
            .name(request.getName())
            .rootPath(normalizeRootPath(request.getRootPath()))
            .status(1)
            .watermarkHigh(request.getWatermarkHigh() != null ? request.getWatermarkHigh() : 90)
            .watermarkLow(request.getWatermarkLow() != null ? request.getWatermarkLow() : 75)
            .priority(request.getPriority() != null ? request.getPriority() : 1)
            .build();
        
        // 4. 初始容量刷新
        refreshCapacity(volume);
        
        // 5. 保存
        volumeRepository.save(volume);
        
        return volume;
    }
    
    private String normalizeRootPath(String path) {
        String normalized = path.replace("\\", "/");
        while (normalized.endsWith("/")) {
            normalized = normalized.substring(0, normalized.length() - 1);
        }
        return normalized;
    }
}
```

**路径规范化的重要性**:

避免这类问题:
```
/recordings  
/recordings/
/recordings//
```
导致拼接错误:
```
/recordings//cam_xxx/2026-02-13/...
```

#### 10.4 自动切卷策略

```java
@Service
@Slf4j
public class RecordingAutoSwitchService {
    
    @Resource
    private RecordingPlanRepository planRepository;
    
    @Resource
    private StorageVolumeService volumeService;
    
    @Resource
    private RecordingPlanService planService;
    
    @Value("${recording.storage.auto-switch-enabled:true}")
    private boolean autoSwitchEnabled;
    
    @Value("${recording.storage.migrate-batch-size:20}")
    private int migrateBatchSize;
    
    @Scheduled(fixedDelayString = "${recording.storage.auto-switch-interval-ms:60000}")
    public void autoSwitch() {
        if (!autoSwitchEnabled) {
            return;
        }
        
        // 1. 查找满盘且有活跃计划的卷
        List<RecordingPlan> affectedPlans = planRepository.findByVolumeFullAndStatusRunning();
        
        if (affectedPlans.isEmpty()) {
            return;
        }
        
        log.info("Found {} plans on full volumes", affectedPlans.size());
        
        // 2. 挑选目标卷
        Optional<StorageVolume> targetVolumeOpt = volumeService.pickWritableVolume();
        
        if (!targetVolumeOpt.isPresent()) {
            log.error("No writable volume available for migration");
            return;
        }
        
        StorageVolume targetVolume = targetVolumeOpt.get();
        
        // 3. 分批迁移
        List<List<RecordingPlan>> batches = partition(affectedPlans, migrateBatchSize);
        
        for (List<RecordingPlan> batch : batches) {
            migrateBatch(batch, targetVolume.getId());
            
            // 避免瞬时风暴
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }
    
    private void migrateBatch(List<RecordingPlan> plans, Long targetVolumeId) {
        for (RecordingPlan plan : plans) {
            try {
                planService.switchVolume(plan.getStreamName(), targetVolumeId);
                log.info("Migrated plan {} to volume {}", plan.getId(), targetVolumeId);
            } catch (Exception e) {
                log.error("Failed to migrate plan {}", plan.getId(), e);
            }
        }
    }
    
    private <T> List<List<T>> partition(List<T> list, int size) {
        List<List<T>> batches = new ArrayList<>();
        for (int i = 0; i < list.size(); i += size) {
            batches.add(list.subList(i, Math.min(i + size, list.size())));
        }
        return batches;
    }
}
```

**为什么需要分批迁移?**

一次性迁移 500 个计划:

- MediaMTX API 并发压力
- 数据库连接池耗尽
- 路径重建风暴

分批策略:

- 每批 20 个,批次间延迟 1 秒
- 总耗时可控,系统压力平滑

------

### 11. 录像策略编排

#### 11.1 录像计划表设计

```sql
DROP TABLE IF EXISTS `recording_plan`;
CREATE TABLE `recording_plan` (
  `id`                 BIGINT NOT NULL AUTO_INCREMENT,
  `camera_id`          BIGINT NOT NULL COMMENT '相机ID',
  `stream_name`        VARCHAR(128) NOT NULL COMMENT '媒体路径名',
  `rtsp_url`           VARCHAR(1024) DEFAULT NULL COMMENT '源RTSP(可回填)',
  
  -- 存储配置
  `volume_id`          BIGINT NOT NULL COMMENT '写入卷ID',
  `status`             TINYINT NOT NULL DEFAULT 0 COMMENT '1运行 0停止',
  `record_mode`        VARCHAR(20) DEFAULT 'auto' COMMENT 'auto/schedule/event',
  `week_schedule`      JSON DEFAULT NULL COMMENT 'schedule模式的周配置',
  
  -- 录像参数
  `retention_days`     INT NOT NULL DEFAULT 7 COMMENT '保留天数',
  `segment_duration`   VARCHAR(16) NOT NULL DEFAULT '10m' COMMENT '切片时长',
  `record_format`      VARCHAR(16) NOT NULL DEFAULT 'fmp4' COMMENT '录像格式',
  `record_path_mask`   VARCHAR(512) DEFAULT NULL COMMENT '落盘路径模板',
  
  -- 版本控制
  `apply_version`      BIGINT NOT NULL DEFAULT 0 COMMENT '下发版本号',
  `last_apply_time`    DATETIME DEFAULT NULL COMMENT '最后下发时间',
  
  `create_by`          VARCHAR(64) DEFAULT 'system',
  `create_time`        DATETIME DEFAULT CURRENT_TIMESTAMP,
  `update_time`        DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_stream_name` (`stream_name`),
  KEY `idx_camera_status` (`camera_id`, `status`),
  KEY `idx_volume_status` (`volume_id`, `status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='录像计划表';

```

**设计要点**:

1. **流名唯一性**
    - `uk_stream_name`:一条流只有一个生效计划
    - 避免重复录像

2. **版本控制**
    - `apply_version`:每次下发递增
    - 用于审计和幂等性判断

3. **路径模板落库**
    - `record_path_mask`:实际使用的路径模板
    - 便于排障和迁移

#### 11.2 录像路径模板

**推荐模板**:
```
{rootPath}/%path/%Y-%m-%d/%H-%M-%S
```

**路径示例**:
```
/recordings/cam_10_0_1_20_ch1_main/2026-02-13/14-00-00.mp4
/recordings/cam_10_0_1_20_ch1_main/2026-02-13/14-10-00.mp4
/recordings/cam_10_0_1_20_ch1_main/2026-02-13/14-20-00.mp4
```

**模板变量说明**:

| 变量    | 含义     | 示例                   |
| ------- | -------- | ---------------------- |
| `%path` | 流路径名 | cam_10_0_1_20_ch1_main |
| `%Y`    | 年份     | 2026                   |
| `%m`    | 月份     | 02                     |
| `%d`    | 日期     | 13                     |
| `%H`    | 小时     | 14                     |
| `%M`    | 分钟     | 00                     |
| `%S`    | 秒       | 00                     |

**为什么按日期分桶?**

1. **清理便利**:删除过期录像直接 `rm -rf 2026-01-01`
2. **检索优化**:时间范围查询可按目录过滤
3. **备份友好**:按天归档到对象存储

#### 11.3 录像计划应用

```java
@Service
@Slf4j
public class RecordingPlanService {
    
    @Resource
    private RecordingPlanRepository planRepository;
    
    @Resource
    private StorageVolumeService volumeService;
    
    @Resource
    private StreamPathRepository streamPathRepository;
    
    @Resource
    private MediaGatewayClient mediaGatewayClient;
    
    @Transactional(rollbackFor = Exception.class)
    public void applyPlan(RecordingConfigRequest request) {
        // 1. 参数校验
        validateRequest(request);
        
        // 2. 解析源地址
        String sourceUrl = resolveRtspUrl(request);
        
        // 3. 加载存储卷
        StorageVolume volume = volumeService.getById(request.getVolumeId());
        if (volume == null || volume.getStatus() != 1) {
            throw new BusinessException("存储卷不可用: " + request.getVolumeId());
        }
        
        // 4. 构建录像路径
        String rootPath = normalizeRootPath(volume.getRootPath());
        String recordPath = rootPath + "/%path/%Y-%m-%d/%H-%M-%S";
        
        // 5. 下发 MediaMTX 配置
        try {
            mediaGatewayClient.updateRecordingConfig(
                request.getStreamName(),
                sourceUrl,
                request.getEnabled(),
                recordPath,
                request.getRetentionDays(),
                request.getSegmentDuration()
            );
        } catch (Exception e) {
            log.error("MediaMTX config failed for {}", request.getStreamName(), e);
            throw new MediaGatewayException("录像配置下发失败", e);
        }
        
        // 6. 保存/更新计划
        RecordingPlan plan = planRepository.findByStreamName(request.getStreamName())
            .orElseGet(RecordingPlan::new);
        
        plan.setCameraId(request.getCameraId());
        plan.setStreamName(request.getStreamName());
        plan.setRtspUrl(sourceUrl);
        plan.setVolumeId(request.getVolumeId());
        plan.setStatus(Boolean.TRUE.equals(request.getEnabled()) ? 1 : 0);
        plan.setRecordMode("auto");
        plan.setRetentionDays(request.getRetentionDays());
        plan.setSegmentDuration(request.getSegmentDuration());
        plan.setRecordFormat("fmp4");
        plan.setRecordPathMask(recordPath);
        
        // 版本递增
        long nextVersion = (plan.getApplyVersion() == null ? 0 : plan.getApplyVersion()) + 1;
        plan.setApplyVersion(nextVersion);
        plan.setLastApplyTime(LocalDateTime.now());
        
        planRepository.saveOrUpdate(plan);
        
        log.info("Recording plan applied: stream={}, version={}", 
            request.getStreamName(), nextVersion);
    }
    
    private String resolveRtspUrl(RecordingConfigRequest request) {
        if (StringUtils.isNotBlank(request.getRtspUrl())) {
            return request.getRtspUrl();
        }
        
        return streamPathRepository.findByPathName(request.getStreamName())
            .map(StreamPath::getSourceUrl)
            .orElseThrow(() -> new BusinessException("未找到流路径: " + request.getStreamName()));
    }
    
    private void validateRequest(RecordingConfigRequest request) {
        if (StringUtils.isBlank(request.getStreamName())) {
            throw new IllegalArgumentException("streamName 不能为空");
        }
        if (request.getVolumeId() == null) {
            throw new IllegalArgumentException("volumeId 不能为空");
        }
        if (request.getRetentionDays() == null || request.getRetentionDays() <= 0) {
            throw new IllegalArgumentException("retentionDays 必须为正数");
        }
    }
    
    private String normalizeRootPath(String path) {
        String normalized = path.replace("\\", "/");
        while (normalized.endsWith("/")) {
            normalized = normalized.substring(0, normalized.length() - 1);
        }
        return normalized;
    }
}
```

#### 11.4 MediaMTX 录像配置下发

```java
@Component
@Slf4j
public class MediaGatewayClient {
    
    @Value("${media.mtx.apiBaseUrl}")
    private String apiBaseUrl;
    
    private final RestTemplate restTemplate;
    
    public void updateRecordingConfig(String pathName,
                                      String sourceUrl,
                                      boolean recordEnabled,
                                      String recordPath,
                                      int retentionDays,
                                      String segmentDuration) {
        
        Map<String, Object> payload = new HashMap<>();
        payload.put("name", pathName);
        payload.put("source", sourceUrl);
        payload.put("sourceProtocol", "tcp");
        payload.put("sourceOnDemand", false);
        
        if (recordEnabled) {
            payload.put("record", true);
            payload.put("recordPath", recordPath);
            payload.put("recordFormat", "fmp4");
            payload.put("recordPartDuration", "1s");
            payload.put("recordSegmentDuration", 
                StringUtils.isBlank(segmentDuration) ? "10m" : segmentDuration);
            payload.put("recordDeleteAfter", retentionDays + "d");
        } else {
            payload.put("record", false);
        }
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        HttpEntity<Map<String, Object>> request = new HttpEntity<>(payload, headers);
        
        String baseUrl = apiBaseUrl.endsWith("/") 
            ? apiBaseUrl.substring(0, apiBaseUrl.length() - 1) 
            : apiBaseUrl;
        
        try {
            // Delete existing path
            try {
                restTemplate.delete(baseUrl + "/v3/config/paths/delete/" + pathName);
            } catch (HttpClientErrorException.NotFound e) {
                // Path doesn't exist, ignore
            }
            
            // Add new path
            ResponseEntity<String> response = restTemplate.postForEntity(
                baseUrl + "/v3/config/paths/add/" + pathName,
                request,
                String.class
            );
            
            if (!response.getStatusCode().is2xxSuccessful()) {
                throw new MediaGatewayException("MediaMTX返回错误: " + response.getBody());
            }
            
            log.info("Recording config applied: {}", pathName);
            
        } catch (Exception e) {
            log.error("MediaMTX API调用失败: {}", e.getMessage());
            throw new MediaGatewayException("录像配置下发失败", e);
        }
    }
}
```

**Delete + Add 的必要性**:

1. **配置清洁**:避免旧参数残留
2. **立即生效**:不需要等待旧切片结束
3. **幂等性**:重复执行结果一致

**风险缓解**:

```java
@Retryable(
    value = {MediaGatewayException.class},
    maxAttempts = 3,
    backoff = @Backoff(delay = 1000, multiplier = 2)
)
public void updateRecordingConfig(...) {
    // 实现
}
```

#### 11.5 切换存储卷

```java
@Service
public class RecordingPlanService {
    
    @Transactional(rollbackFor = Exception.class)
    public void switchVolume(String streamName, Long newVolumeId) {
        RecordingPlan plan = planRepository.findByStreamName(streamName)
            .orElseThrow(() -> new NotFoundException("录像计划不存在: " + streamName));
        
        // 构造切换请求
        RecordingConfigRequest request = new RecordingConfigRequest();
        request.setCameraId(plan.getCameraId());
        request.setStreamName(streamName);
        request.setRtspUrl(null); // 自动回查
        request.setVolumeId(newVolumeId);
        request.setEnabled(plan.getStatus() == 1);
        request.setRetentionDays(plan.getRetentionDays());
        request.setSegmentDuration(plan.getSegmentDuration());
        
        // 重新应用计划
        applyPlan(request);
        
        log.info("Volume switched for {}: {} -> {}", 
            streamName, plan.getVolumeId(), newVolumeId);
    }
    
    @Transactional(rollbackFor = Exception.class)
    public void stopRecording(String streamName) {
        RecordingPlan plan = planRepository.findByStreamName(streamName)
            .orElseThrow(() -> new NotFoundException("录像计划不存在: " + streamName));
        
        RecordingConfigRequest request = new RecordingConfigRequest();
		request.setCameraId(plan.getCameraId());
		request.setStreamName(streamName);
		request.setVolumeId(plan.getVolumeId());
		request.setRetentionDays(plan.getRetentionDays());
		request.setSegmentDuration(plan.getSegmentDuration());
		request.setEnabled(false);    applyPlan(request);    
        log.info("Recording stopped for {}", streamName);
	}
}
```

### 12. 文件索引与回放检索

#### 12.1 录像文件索引表
```sql
DROP TABLE IF EXISTS `recording_file`;
CREATE TABLE `recording_file` (
  `id`               BIGINT NOT NULL AUTO_INCREMENT,
  `camera_id`        BIGINT NOT NULL,
  `stream_name`      VARCHAR(128) NOT NULL,
  `volume_id`        BIGINT NOT NULL,
  
  -- 文件信息
  `file_path`        VARCHAR(1024) NOT NULL COMMENT '完整路径',
  `file_name`        VARCHAR(255) NOT NULL COMMENT '文件名',
  `file_size`        BIGINT DEFAULT 0 COMMENT '文件大小(Byte)',
  `codec`            VARCHAR(16) DEFAULT NULL COMMENT '编码格式',
  
  -- 时间信息
  `start_time`       DATETIME NOT NULL COMMENT '开始时间',
  `end_time`         DATETIME DEFAULT NULL COMMENT '结束时间',
  `duration_sec`     INT DEFAULT 0 COMMENT '时长(秒)',
  
  -- 状态
  `status`           TINYINT NOT NULL DEFAULT 2 COMMENT '1录制中 2已完成 3异常',
  
  `created_by`       VARCHAR(64) DEFAULT 'indexer',
  `create_time`      DATETIME DEFAULT CURRENT_TIMESTAMP,
  `update_time`      DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_file_path` (`file_path`),
  KEY `idx_stream_time` (`stream_name`, `start_time`),
  KEY `idx_camera_time` (`camera_id`, `start_time`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='录像文件索引表';
```

**设计要点**:

1. **文件路径唯一性**
    - `uk_file_path`:防止重复索引
    - 支持幂等扫描

2. **时间检索优化**
    - `idx_stream_time`:按流名+时间查询
    - `idx_camera_time`:按相机+时间统计

3. **状态区分**
    - `1 录制中`:正在写入
    - `2 已完成`:完整切片
    - `3 异常`:意外中断

#### 12.2 文件索引器
```java
@Component
@Slf4j
public class RecordingFileIndexer {
    
    private static final Pattern SEGMENT_PATTERN = 
        Pattern.compile("(\\d{2})-(\\d{2})-(\\d{2})\\.(mp4|m4s)$");
    
    @Resource
    private StorageVolumeRepository volumeRepository;
    
    @Resource
    private RecordingPlanRepository planRepository;
    
    @Resource
    private RecordingFileRepository fileRepository;
    
    @Value("${recording.index.scan-depth:4}")
    private int scanDepth;
    
    @Value("${recording.index.lookback-hours:24}")
    private int lookbackHours;
    
    @Scheduled(fixedDelayString = "${recording.index.fixed-delay-ms:30000}")
    public void scanAndUpsert() {
        List<StorageVolume> volumes = volumeRepository.findByStatus(1);
        
        for (StorageVolume volume : volumes) {
            try {
                scanVolume(volume);
            } catch (Exception e) {
                log.error("Failed to scan volume {}", volume.getId(), e);
            }
        }
    }
    
    private void scanVolume(StorageVolume volume) {
        Path rootPath = Paths.get(volume.getRootPath());
        
        if (!Files.exists(rootPath)) {
            log.warn("Volume root not exists: {}", volume.getRootPath());
            return;
        }
        
        try (Stream<Path> stream = Files.walk(rootPath, scanDepth)) {
            stream.filter(Files::isRegularFile)
                .filter(this::isSegmentFile)
                .filter(this::isRecentFile)
                .forEach(file -> upsertSegment(volume, file));
        } catch (IOException e) {
            log.error("Failed to walk volume {}", volume.getId(), e);
        }
    }
    
    private boolean isSegmentFile(Path path) {
        String name = path.getFileName().toString().toLowerCase();
        return name.endsWith(".mp4") || name.endsWith(".m4s");
    }
    
    private boolean isRecentFile(Path path) {
        try {
            FileTime modified = Files.getLastModifiedTime(path);
            LocalDateTime modifiedTime = LocalDateTime.ofInstant(
                modified.toInstant(),
                ZoneId.systemDefault()
            );
            
            LocalDateTime cutoff = LocalDateTime.now().minusHours(lookbackHours);
            return modifiedTime.isAfter(cutoff);
            
        } catch (IOException e) {
            return false;
        }
    }
    
    private void upsertSegment(StorageVolume volume, Path file) {
        try {
            SegmentMeta meta = parseSegmentMeta(volume, file);
            if (meta == null) {
                return;
            }
            
            RecordingFile entity = meta.toEntity();
            fileRepository.upsert(entity);
            
        } catch (Exception e) {
            log.error("Failed to upsert segment: {}", file, e);
        }
    }
    
    private SegmentMeta parseSegmentMeta(StorageVolume volume, Path file) {
        String filePath = file.toString();
        String fileName = file.getFileName().toString();
        
        // 解析路径: /recordings/{streamName}/{date}/{time}.mp4
        String[] parts = filePath.replace(volume.getRootPath(), "")
            .split("/");
        
        if (parts.length < 3) {
            log.warn("Invalid file path structure: {}", filePath);
            return null;
        }
        
        String streamName = parts[parts.length - 3];
        String dateStr = parts[parts.length - 2]; // 2026-02-13
        
        // 解析时间
        Matcher matcher = SEGMENT_PATTERN.matcher(fileName);
        if (!matcher.find()) {
            log.warn("Invalid file name pattern: {}", fileName);
            return null;
        }
        
        String hour = matcher.group(1);
        String minute = matcher.group(2);
        String second = matcher.group(3);
        
        String startTimeStr = dateStr + " " + hour + ":" + minute + ":" + second;
        LocalDateTime startTime = LocalDateTime.parse(startTimeStr,
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
        
        // 查询计划获取相机ID
        Long cameraId = planRepository.findByStreamName(streamName)
            .map(RecordingPlan::getCameraId)
            .orElse(null);
        
        if (cameraId == null) {
            log.warn("No plan found for stream: {}", streamName);
            return null;
        }
        
        // 获取文件大小
        long fileSize;
        try {
            fileSize = Files.size(file);
        } catch (IOException e) {
            fileSize = 0;
        }
        
        return SegmentMeta.builder()
            .cameraId(cameraId)
            .streamName(streamName)
            .volumeId(volume.getId())
            .filePath(filePath)
            .fileName(fileName)
            .fileSize(fileSize)
            .startTime(startTime)
            .status(2) // 已完成
            .build();
    }
}

@Data
@Builder
class SegmentMeta {
    private Long cameraId;
    private String streamName;
    private Long volumeId;
    private String filePath;
    private String fileName;
    private Long fileSize;
    private LocalDateTime startTime;
    private Integer status;
    
    public RecordingFile toEntity() {
        RecordingFile file = new RecordingFile();
        file.setCameraId(this.cameraId);
        file.setStreamName(this.streamName);
        file.setVolumeId(this.volumeId);
        file.setFilePath(this.filePath);
        file.setFileName(this.fileName);
        file.setFileSize(this.fileSize);
        file.setStartTime(this.startTime);
        file.setStatus(this.status);
        return file;
    }
}
```

**索引策略优化**:

1. **扫描窗口限制**
    - 只扫描最近 24 小时的文件
    - 避免全盘遍历

2. **幂等性保证**
    - `uk_file_path` 确保重复扫描不产生重复记录
    - `upsert` 语义:存在则更新,不存在则插入

3. **并发控制**
    - 定时任务单线程执行
    - 避免并发扫描导致重复写入



#### 12.3 回放查询服务
```java
@Service
public class RecordingPlaybackService {
    
    @Resource
    private RecordingFileRepository fileRepository;
    
    /**
     * 按时间范围查询录像片段
     */
    public List<RecordingFile> queryByTimeRange(
            String streamName,
            LocalDateTime start,
            LocalDateTime end) {
        
        return fileRepository.findByStreamNameAndTimeRange(streamName, start, end);
    }
    
    /**
     * 生成 M3U8 播放列表
     */
    public String generateM3U8(String streamName, 
                               LocalDateTime start, 
                               LocalDateTime end) {
        
        List<RecordingFile> files = queryByTimeRange(streamName, start, end);
        
        if (files.isEmpty()) {
            throw new NotFoundException("未找到录像文件");
        }
        
        StringBuilder m3u8 = new StringBuilder();
        m3u8.append("#EXTM3U\n");
        m3u8.append("#EXT-X-VERSION:3\n");
        m3u8.append("#EXT-X-TARGETDURATION:600\n"); // 10分钟
        m3u8.append("#EXT-X-MEDIA-SEQUENCE:0\n");
        
        for (RecordingFile file : files) {
            m3u8.append("#EXTINF:").append(file.getDurationSec()).append(",\n");
            m3u8.append(buildPlayUrl(file)).append("\n");
        }
        
        m3u8.append("#EXT-X-ENDLIST\n");
        
        return m3u8.toString();
    }
    
    private String buildPlayUrl(RecordingFile file) {
        // 返回文件访问地址
        // 可以是 HTTP 静态文件服务,也可以是对象存储 URL
        return "/recordings/" + file.getStreamName() + "/" + file.getFileName();
    }
}
```

**Repository 实现**:
```java
@Repository
public interface RecordingFileRepository extends BaseMapper<RecordingFile> {
    
    @Select("SELECT * FROM recording_file " +
            "WHERE stream_name = #{streamName} " +
            "AND start_time < #{end} " +
            "AND COALESCE(end_time, DATE_ADD(start_time, INTERVAL duration_sec SECOND)) > #{start} " +
            "ORDER BY start_time ASC")
    List<RecordingFile> findByStreamNameAndTimeRange(
        @Param("streamName") String streamName,
        @Param("start") LocalDateTime start,
        @Param("end") LocalDateTime end
    );
    
    @Insert("INSERT INTO recording_file (...) VALUES (...) " +
            "ON DUPLICATE KEY UPDATE file_size=VALUES(file_size), status=VALUES(status)")
    void upsert(RecordingFile file);
}
```

**查询优化**:

时间范围查询的关键:
```sql
start_time < end AND end_time > start
```

这个条件能正确处理:
- 完全包含
- 部分重叠
- 边界对齐

---

## 第三部分:智能分析平台

### 13. 算法任务模型设计

#### 13.1 任务模型的核心挑战

**问题 1:一个任务一个算法的局限性**

真实场景:
- 厂区门口需要同时检测:人员入侵、车辆违停、未戴安全帽
- 传统方案:创建 3 个任务,拉流 3 次,浪费带宽和算力

**问题 2:多场景任务的状态复杂性**

- 同一任务的不同场景可能分配到不同算法节点
- 需要同时维护任务级状态和场景级状态
- 部分场景失败不应影响其他场景

#### 13.2 任务表设计
```sql
DROP TABLE IF EXISTS `ai_task`;
CREATE TABLE `ai_task` (
  `id`                    BIGINT NOT NULL AUTO_INCREMENT,
  `task_name`             VARCHAR(255) DEFAULT NULL COMMENT '任务名称',
  `camera_id`             BIGINT DEFAULT NULL COMMENT '相机ID',
  `group_id`              BIGINT DEFAULT NULL COMMENT '分组ID',
  `camera_name`           VARCHAR(255) DEFAULT NULL COMMENT '相机名称(冗余)',
  `stream_path_id`        BIGINT DEFAULT NULL COMMENT '流路径ID',
  
  -- 流信息
  `rtsp_url`              VARCHAR(1024) DEFAULT NULL COMMENT 'RTSP源地址',
  `stream_path_name`      VARCHAR(255) DEFAULT NULL COMMENT '流路径名',
  `stream_type`           TINYINT DEFAULT 0 COMMENT '0主码流 1子码流',
  
  -- 算法配置
  `scene_codes`           JSON DEFAULT NULL COMMENT '场景编码数组',
  `region_json`           TEXT COMMENT '检测区域',
  `algorithm_params`      TEXT COMMENT '算法参数',
  
  -- 调度配置
  `dispatch_mode`         VARCHAR(20) DEFAULT 'MIXED' COMMENT 'MIXED/AUTO_SINGLE/AUTO_SPLIT/FIXED',
  `prefer_node_id`        BIGINT DEFAULT NULL COMMENT '指定节点ID(FIXED模式)',
  
  -- 检测参数
  `conf_threshold`        FLOAT DEFAULT 0.6 COMMENT '置信度阈值',
  `alarm_enabled`         TINYINT DEFAULT 1 COMMENT '是否告警',
  `level`                 INT DEFAULT 1 COMMENT '告警等级',
  
  -- 视频处理参数
  `input_fps`             INT DEFAULT 15 COMMENT '输入帧率',
  `output_fps`            INT DEFAULT 15 COMMENT '输出帧率',
  `output_width`          INT DEFAULT 1280 COMMENT '输出宽度',
  `output_height`         INT DEFAULT 720 COMMENT '输出高度',
  `output_bitrate`        VARCHAR(20) DEFAULT '3000k' COMMENT '输出码率',
  `process_quality`       VARCHAR(20) DEFAULT 'MEDIUM' COMMENT 'LOW/MEDIUM/HIGH',
  
  -- 快照配置
  `snapshot_policy`       VARCHAR(16) DEFAULT 'ALARM' COMMENT 'OFF/ALL/ALARM',
  `snapshot_quality`      INT DEFAULT 80 COMMENT '快照质量(1-100)',
  
  -- 推送配置
  `push_enabled`          TINYINT DEFAULT 1 COMMENT '是否推送',
  `push_mode`             VARCHAR(32) DEFAULT 'LEVEL_DEFAULT' COMMENT '推送模式',
  `push_threshold_count`  INT DEFAULT NULL COMMENT '推送阈值次数',
  `push_window_seconds`   INT DEFAULT NULL COMMENT '推送窗口秒数',
  `push_cooldown_seconds` INT DEFAULT 0 COMMENT '推送冷却秒数',
  `push_route_key`        VARCHAR(64) DEFAULT NULL COMMENT '推送路由键',
  
  -- 运行状态
  `status`                TINYINT DEFAULT 0 COMMENT '0停止 1运行 2异常',
  `error_count`           INT DEFAULT 0 COMMENT '错误次数',
  `error_message`         VARCHAR(1024) DEFAULT NULL COMMENT '错误消息',
  `last_run_time`         DATETIME DEFAULT NULL COMMENT '最后运行时间',
  `last_keepalive_time`   DATETIME DEFAULT NULL COMMENT '最后心跳时间',
  
  `create_time`           DATETIME DEFAULT CURRENT_TIMESTAMP,
  `update_time`           DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  PRIMARY KEY (`id`),
  KEY `idx_camera_status` (`camera_id`, `status`),
  KEY `idx_group_id` (`group_id`),
  KEY `idx_dispatch_mode` (`dispatch_mode`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='算法任务表';
```

**JSON 字段示例**:
```json
{
  "scene_codes": ["REGION_INTRUSION", "HELMET_DETECTION", "VEHICLE_PARKING"]
}
```

#### 13.3 场景分类表
```sql
DROP TABLE IF EXISTS `ai_scene_category`;
CREATE TABLE `ai_scene_category` (
  `id`             BIGINT NOT NULL AUTO_INCREMENT,
  `category_name`  VARCHAR(64) NOT NULL COMMENT '分类名称',
  `category_code`  VARCHAR(64) NOT NULL COMMENT '分类编码',
  `icon`           VARCHAR(128) DEFAULT NULL COMMENT '图标',
  `sort_order`     INT DEFAULT 0 COMMENT '排序',
  `status`         TINYINT DEFAULT 1 COMMENT '状态',
  `create_time`    DATETIME DEFAULT CURRENT_TIMESTAMP,
  `update_time`    DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_category_code` (`category_code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='场景分类表';
```

**示例数据**:
```sql
INSERT INTO ai_scene_category (category_name, category_code, sort_order) VALUES
('安全管理', 'SAFETY', 1),
('行为识别', 'BEHAVIOR', 2),
('车辆管理', 'VEHICLE', 3),
('环境监测', 'ENVIRONMENT', 4);
```

#### 13.4 场景类型表
```sql
DROP TABLE IF EXISTS `ai_scene_type`;
CREATE TABLE `ai_scene_type` (
  `id`              BIGINT NOT NULL AUTO_INCREMENT,
  `category_id`     BIGINT NOT NULL COMMENT '分类ID',
  `scene_name`      VARCHAR(100) NOT NULL COMMENT '场景名称',
  `scene_code`      VARCHAR(64) NOT NULL COMMENT '场景编码',
  `algorithm_type`  VARCHAR(32) DEFAULT NULL COMMENT '算法类型',
  `model_path`      VARCHAR(255) DEFAULT NULL COMMENT '模型路径',
  `default_params`  JSON DEFAULT NULL COMMENT '默认参数',
  `description`     VARCHAR(500) DEFAULT NULL COMMENT '描述',
  `icon`            VARCHAR(128) DEFAULT NULL COMMENT '图标',
  `status`          TINYINT DEFAULT 1 COMMENT '状态',
  `create_time`     DATETIME DEFAULT CURRENT_TIMESTAMP,
  `update_time`     DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_scene_code` (`scene_code`),
  KEY `idx_category_status` (`category_id`, `status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='场景类型表';
```

**示例数据**:
```sql
INSERT INTO ai_scene_type (category_id, scene_name, scene_code, algorithm_type, default_params) VALUES
(1, '区域入侵检测', 'REGION_INTRUSION', 'object_detection', 
 '{"problem_labels":["person","vehicle"],"conf_threshold":0.6}'),
(1, '安全帽检测', 'HELMET_DETECTION', 'classification',
 '{"problem_labels":["no_helmet"],"conf_threshold":0.7}'),
(3, '车辆违停检测', 'VEHICLE_PARKING', 'object_detection',
 '{"problem_labels":["car","truck"],"conf_threshold":0.6}');
```

#### 13.5 任务请求模型
```java
@Data
public class AiTaskUpsertRequest {
    private Long id;
    private String taskName;
    
    // 相机绑定
    private Long cameraId;
    private Long streamPathId;
    private String rtspUrl;
    private Integer streamType; // 0主码流 1子码流
    
    // 场景配置 (核心)
    private List<String> sceneCodes;
    
    // 检测区域
    private String regionJson;
    private String algorithmParams;
    
    // 调度配置
    private String dispatchMode; // MIXED/AUTO_SINGLE/AUTO_SPLIT/FIXED
    private Long preferNodeId;
    
    // 检测参数
    private Float confThreshold;
    private Integer alarmEnabled;
    private Integer level;
    
    // 视频处理
    private Integer inputFps;
    private Integer outputFps;
    private Integer outputWidth;
    private Integer outputHeight;
    private String outputBitrate;
    private String processQuality;
    
    // 快照配置
    private String snapshotPolicy;
    private Integer snapshotQuality;
    
    // 推送配置
    private Integer pushEnabled;
    private String pushMode;
    private Integer pushThresholdCount;
    private Integer pushWindowSeconds;
    private Integer pushCooldownSeconds;
    private String pushRouteKey;
}
```

#### 13.6 任务创建服务
```java
@Service
@Slf4j
public class AiTaskService {
    
    @Resource
    private AiTaskRepository taskRepository;
    
    @Resource
    private CameraDeviceRepository cameraRepository;
    
    @Resource
    private StreamPathRepository streamPathRepository;
    
    @Transactional(rollbackFor = Exception.class)
    public AiTask createTask(AiTaskUpsertRequest request) {
        // 1. 参数规范化
        normalizeRequest(request);
        
        // 2. 查询相机信息
        CameraDevice camera = cameraRepository.findById(request.getCameraId())
            .orElseThrow(() -> new NotFoundException("相机不存在"));
        
        // 3. 解析流路径
        StreamPath streamPath = resolveStreamPath(request);
        
        // 4. 构建任务实体
        AiTask task = new AiTask();
        BeanUtils.copyProperties(request, task);
        
        task.setCameraName(camera.getCameraName());
        task.setGroupId(camera.getGroupId());
        task.setStreamPathName(streamPath.getPathName());
        task.setRtspUrl(streamPath.getSourceUrl());
        task.setStatus(0); // 初始停止状态
        
        // 5. 保存
        taskRepository.save(task);
        
        log.info("Task created: id={}, camera={}, scenes={}", 
            task.getId(), task.getCameraId(), task.getSceneCodes());
        
        return task;
    }
    
    private void normalizeRequest(AiTaskUpsertRequest request) {
        // 场景编码去重
        if (request.getSceneCodes() != null) {
            request.setSceneCodes(
                request.getSceneCodes().stream()
                    .filter(StringUtils::isNotBlank)
                    .distinct()
                    .collect(Collectors.toList())
            );
        }
        
        // 默认值设置
        if (request.getInputFps() == null) request.setInputFps(15);
        if (request.getOutputFps() == null) request.setOutputFps(request.getInputFps());
        if (request.getOutputWidth() == null) request.setOutputWidth(1280);
        if (request.getOutputHeight() == null) request.setOutputHeight(720);
        if (request.getOutputBitrate() == null) request.setOutputBitrate("3000k");
        if (request.getProcessQuality() == null) request.setProcessQuality("MEDIUM");
        if (request.getDispatchMode() == null) request.setDispatchMode("MIXED");
        if (request.getConfThreshold() == null) request.setConfThreshold(0.6f);
        if (request.getAlarmEnabled() == null) request.setAlarmEnabled(1);
        if (request.getSnapshotPolicy() == null) request.setSnapshotPolicy("ALARM");
        if (request.getSnapshotQuality() == null) request.setSnapshotQuality(80);
    }
    
    private StreamPath resolveStreamPath(AiTaskUpsertRequest request) {
        if (request.getStreamPathId() != null) {
            return streamPathRepository.findById(request.getStreamPathId())
                .orElseThrow(() -> new NotFoundException("流路径不存在"));
        }
        
        // 按类型查找
        Integer subtype = (request.getStreamType() != null && request.getStreamType() == 1) ? 1 : 0;
        
        return streamPathRepository.findByCameraIdAndSubtype(request.getCameraId(), subtype)
            .orElseThrow(() -> new NotFoundException("未找到流路径"));
    }
}
```

---

### 14. 算法节点管理与调度

#### 14.1 算法节点表
```sql
DROP TABLE IF EXISTS `ai_engine_node`;
CREATE TABLE `ai_engine_node` (
  `id`                   BIGINT NOT NULL AUTO_INCREMENT,
  `node_id`              VARCHAR(100) NOT NULL COMMENT '节点唯一标识',
  `node_name`            VARCHAR(100) DEFAULT NULL COMMENT '节点名称',
  `ip`                   VARCHAR(64) NOT NULL COMMENT 'IP地址',
  `port`                 INT DEFAULT NULL COMMENT '端口',
  `status`               TINYINT DEFAULT 0 COMMENT '1在线 0离线 2异常',
  `last_heartbeat_time`  DATETIME DEFAULT NULL COMMENT '最后心跳时间',
  
  -- 能力信息
  `scene_name_json`      JSON DEFAULT NULL COMMENT '支持场景名称',
  `scene_code_json`      JSON DEFAULT NULL COMMENT '支持场景编码',
  
  -- 负载信息
  `load_info`            JSON DEFAULT NULL COMMENT '负载信息',
  `max_tasks`            INT DEFAULT 50 COMMENT '最大任务数',
  
  `create_time`          DATETIME DEFAULT CURRENT_TIMESTAMP,
  `update_time`          DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_node_id` (`node_id`),
  KEY `idx_status_heartbeat` (`status`, `last_heartbeat_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='算法节点表';
```

**JSON 字段示例**:
```json
{
  "scene_code_json": ["REGION_INTRUSION", "HELMET_DETECTION", "FIRE_DETECTION"],
  "load_info": {
    "cpu": 0.42,
    "gpu": 0.68,
    "memory": 0.55,
    "tasks": 12
  }
}
```

#### 14.2 任务运行态表
```sql
DROP TABLE IF EXISTS `ai_task_runtime`;
CREATE TABLE `ai_task_runtime` (
  `task_id`           BIGINT NOT NULL COMMENT '任务ID',
  `node_id`           VARCHAR(100) NOT NULL COMMENT '主节点ID',
  `state`             VARCHAR(20) NOT NULL COMMENT 'RUNNING/STOPPED/ERROR',
  `start_time`        DATETIME DEFAULT NULL COMMENT '启动时间',
  `last_keepalive`    DATETIME DEFAULT NULL COMMENT '最后心跳',
  `restart_count`     INT DEFAULT 0 COMMENT '重启次数',
  `preview_path`      VARCHAR(255) DEFAULT NULL COMMENT '预览路径',
  `preview_play_url`  VARCHAR(512) DEFAULT NULL COMMENT '预览播放地址',
  `update_time`       DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`task_id`),
  KEY `idx_node_state` (`node_id`, `state`),
  KEY `idx_keepalive` (`last_keepalive`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='任务运行态表';
```

#### 14.3 场景运行态表
```sql
DROP TABLE IF EXISTS `ai_task_scene_runtime`;
CREATE TABLE `ai_task_scene_runtime` (
  `task_id`         BIGINT NOT NULL COMMENT '任务ID',
  `scene_code`      VARCHAR(50) NOT NULL COMMENT '场景编码',
  `node_id`         VARCHAR(100) DEFAULT NULL COMMENT '执行节点ID',
  `state`           VARCHAR(20) NOT NULL COMMENT 'RUNNING/STOPPED/ERROR',
  `start_time`      DATETIME DEFAULT NULL COMMENT '启动时间',
  `last_keepalive`  DATETIME DEFAULT NULL COMMENT '最后心跳',
  `restart_count`   INT DEFAULT 0 COMMENT '重启次数',
  `error_message`   VARCHAR(500) DEFAULT NULL COMMENT '错误消息',
  `update_time`     DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`task_id`, `scene_code`),
  KEY `idx_node_state` (`node_id`, `state`),
  KEY `idx_keepalive` (`last_keepalive`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='场景运行态表';
```

**为什么需要两层运行态?**

1. **任务级运行态** (`ai_task_runtime`)
    - 记录任务整体状态
    - 绑定主节点 (用于预览)
    - 统计全局心跳

2. **场景级运行态** (`ai_task_scene_runtime`)
    - 支持场景拆分到不同节点
    - 独立监控每个场景状态
    - 精准故障定位

#### 14.4 调度策略实现
```java
@Service
@Slf4j
public class TaskDispatchService {
    
    @Resource
    private EngineNodeService nodeService;
    
    /**
     * 生成调度计划
     */
    public DispatchPlan buildDispatchPlan(AiTask task, List<String> sceneCodes) {
        String mode = task.getDispatchMode();
        if (mode == null) mode = "MIXED";
        
        Map<String, List<String>> nodeToScenes = new LinkedHashMap<>();
        
        switch (mode) {
            case "FIXED":
                nodeToScenes = dispatchFixed(task, sceneCodes);
                break;
            case "AUTO_SINGLE":
                nodeToScenes = dispatchAutoSingle(sceneCodes);
                break;
            case "AUTO_SPLIT":
                nodeToScenes = dispatchAutoSplit(sceneCodes);
                break;
            case "MIXED":
            default:
                nodeToScenes = dispatchMixed(sceneCodes);
                break;
        }
        
        String primaryNodeId = selectPrimaryNode(nodeToScenes);
        
        return new DispatchPlan(nodeToScenes, primaryNodeId);
    }
    
    /**
     * FIXED: 指定节点运行全部场景
     */
    private Map<String, List<String>> dispatchFixed(AiTask task, List<String> sceneCodes) {
        if (task.getPreferNodeId() == null) {
            throw new BusinessException("FIXED模式必须指定preferNodeId");
        }
        
        String nodeId = nodeService.getNodeIdById(task.getPreferNodeId());
        if (nodeId == null) {
            throw new BusinessException("指定节点不存在");
        }
        
        if (!nodeService.supportsAllSceneCodes(nodeId, sceneCodes)) {
            throw new BusinessException("指定节点不支持全部场景");
        }
        
        Map<String, List<String>> result = new HashMap<>();
        result.put(nodeId, new ArrayList<>(sceneCodes));
        return result;
    }
    
    /**
     * AUTO_SINGLE: 自动选择单节点运行全部场景
     */
    private Map<String, List<String>> dispatchAutoSingle(List<String> sceneCodes) {
        String nodeId = nodeService.selectBestNodeForSceneCodes(sceneCodes);
        
        if (nodeId == null) {
            throw new BusinessException("未找到支持全部场景的节点");
        }
        
        Map<String, List<String>> result = new HashMap<>();
        result.put(nodeId, new ArrayList<>(sceneCodes));
        return result;
    }
    
    /**
     * AUTO_SPLIT: 按场景拆分到不同节点
     */
    private Map<String, List<String>> dispatchAutoSplit(List<String> sceneCodes) {
        Map<String, List<String>> nodeToScenes = new LinkedHashMap<>();
        
        for (String sceneCode : sceneCodes) {
            String nodeId = nodeService.selectBestNodeForSceneCode(sceneCode);
            
            if (nodeId == null) {
                throw new BusinessException("未找到支持场景的节点: " + sceneCode);
            }
            
            nodeToScenes.computeIfAbsent(nodeId, k -> new ArrayList<>()).add(sceneCode);
        }
        
        return nodeToScenes;
    }
    
    /**
     * MIXED: 优先单节点,失败则拆分
     */
    private Map<String, List<String>> dispatchMixed(List<String> sceneCodes) {
        String singleNodeId = nodeService.selectBestNodeForSceneCodes(sceneCodes);
        
        if (singleNodeId != null) {
            Map<String, List<String>> result = new HashMap<>();
            result.put(singleNodeId, new ArrayList<>(sceneCodes));
            return result;
        }
        
        log.info("No single node available, fallback to split mode");
        return dispatchAutoSplit(sceneCodes);
    }
    
    /**
     * 选择主节点 (用于预览)
     */
    private String selectPrimaryNode(Map<String, List<String>> nodeToScenes) {
        // 选择场景数量最多的节点作为主节点
        return nodeToScenes.entrySet().stream()
            .max(Comparator.comparingInt(e -> e.getValue().size()))
            .map(Map.Entry::getKey)
            .orElse(null);
    }
}

@Data
@AllArgsConstructor
class DispatchPlan {
    private Map<String, List<String>> nodeToScenes;
    private String primaryNodeId;
}
```

#### 14.5 节点能力匹配
```java
@Service
@Slf4j
public class EngineNodeService {
    
    @Resource
    private EngineNodeRepository nodeRepository;
    
    @Resource
    private TaskSceneRuntimeRepository sceneRuntimeRepository;
    
    /**
     * 选择最佳节点 (支持全部场景)
     */
    public String selectBestNodeForSceneCodes(List<String> sceneCodes) {
        List<EngineNode> candidates = getCandidateNodes(sceneCodes);
        
        if (candidates.isEmpty()) {
            return null;
        }
        
        // 按负载升序排序
        return candidates.stream()
            .min(Comparator.comparingInt(this::getActiveTaskCount))
            .map(EngineNode::getNodeId)
            .orElse(null);
    }
    
    /**
     * 选择最佳节点 (支持单个场景)
     */
    public String selectBestNodeForSceneCode(String sceneCode) {
        return selectBestNodeForSceneCodes(Collections.singletonList(sceneCode));
    }
    
    /**
     * 获取候选节点
     */
    public List<EngineNode> getCandidateNodes(List<String> sceneCodes) {
        List<EngineNode> allNodes = nodeRepository.findByStatus(1);
        
        return allNodes.stream()
            .filter(node -> supportsAllSceneCodes(node.getNodeId(), sceneCodes))
            .filter(node -> !isOverloaded(node))
            .collect(Collectors.toList());
    }
    
    /**
     * 判断节点是否支持全部场景
     */
    public boolean supportsAllSceneCodes(String nodeId, List<String> sceneCodes) {
        EngineNode node = nodeRepository.findByNodeId(nodeId);
        if (node == null) return false;
        
        List<String> supportedCodes = parseSceneCodes(node.getSceneCodeJson());
        return new HashSet<>(supportedCodes).containsAll(sceneCodes);
    }
    
    /**
     * 获取节点当前运行任务数
     */
    private int getActiveTaskCount(EngineNode node) {
        return sceneRuntimeRepository.countByNodeIdAndState(node.getNodeId(), "RUNNING");
    }
    
    /**
     * 判断节点是否过载
     */
    private boolean isOverloaded(EngineNode node) {
        int activeCount = getActiveTaskCount(node);
        return activeCount >= node.getMaxTasks();
    }
    
    private List<String> parseSceneCodes(String json) {
        if (json == null || json.isEmpty()) {
            return Collections.emptyList();
        }
        
        try {
            return JSON.parseArray(json, String.class);
        } catch (Exception e) {
            log.error("Failed to parse scene codes: {}", json, e);
            return Collections.emptyList();
        }
    }
}
```

---

### 15. WebSocket 协议规范

#### 15.1 协议设计原则

1. **消息类型明确**:每条消息包含 `type` 字段
2. **双向通信**:平台->算法,算法->平台
3. **幂等性**:重复接收相同消息不产生副作用
4. **容错性**:未知消息类型不中断连接

#### 15.2 节点注册消息

**算法节点 -> 平台**:
```json
{
  "type": "NODE_REGISTER",
  "node_id": "gpu-node-01",
  "node_name": "GPU-Server-01",
  "ip": "10.0.10.21",
  "port": 18080,
  "max_tasks": 50,
  "algorithms": ["REGION_INTRUSION", "HELMET_DETECTION", "FIRE_DETECTION"],
  "load": {
    "cpu": 0.21,
    "gpu": 0.64,
    "memory": 0.55,
    "tasks": 6
  }
}
```

**平台处理**:
```java
@ServerEndpoint("/ws/ai-engine")
@Component
public class AiEngineSocket {
    
    private static EngineNodeService nodeService;
    
    private String sessionNodeId;
    
    @OnMessage
    public void onMessage(String message, Session session) {
        try {
            JSONObject msg = JSON.parseObject(message);
            String type = msg.getString("type");
            
            switch (type) {
                case "NODE_REGISTER":
                    handleRegister(msg, session);
                    break;
                case "NODE_HEARTBEAT":
                    handleHeartbeat(msg);
                    break;
                case "TASK_KEEPALIVE":
                    handleTaskKeepalive(msg);
                    break;
                case "AI_RESULT":
                    handleAiResult(msg);
                    break;
                default:
                    log.warn("Unknown message type: {}", type);
            }
        } catch (Exception e) {
            log.error("Message processing failed", e);
        }
    }
    
    private void handleRegister(JSONObject msg, Session session) {
        String nodeId = msg.getString("node_id");
        
        // 会话绑定
        this.sessionNodeId = nodeId;
        session.getUserProperties().put("nodeId", nodeId);
        
        // 更新节点状态
        nodeService.upsertNode(msg);
        
        log.info("Node registered: {}", nodeId);
    }
    
    @OnClose
    public void onClose(Session session) {
        if (sessionNodeId != null) {
            nodeService.markOffline(sessionNodeId);
            log.info("Node disconnected: {}", sessionNodeId);
        }
    }
}
```

#### 15.3 任务控制消息

**平台 -> 算法节点 (启动任务)**:
```json
{
  "type": "START_TASK",
  "data": {
    "task_id": 1001,
    "camera_id": 3001,
    "scene_codes": ["REGION_INTRUSION", "HELMET_DETECTION"],
    "stream_key": "3001:0",
    "rtsp": "rtsp://admin:pass@10.0.1.20:554/Streaming/Channels/101",
    "confThreshold": 0.6,
    "region": [[0.1,0.1],[0.9,0.1],[0.9,0.9],[0.1,0.9]],
    "params": {
      "input_fps": 15,
      "in_w": 1280,
      "in_h": 720,
      "result_fps": 8,
      "quality": "MEDIUM",
      "alarm_enabled": 1,
      "snapshot_policy": "ALARM",
      "snapshot_quality": 80
    }
  }
}
```

**平台 -> 算法节点 (停止任务)**:
```json
{
  "type": "STOP_TASK",
  "data": {
    "task_id": 1001
  }
}
```

#### 15.4 结果上报消息

**算法节点 -> 平台 (单场景结果)**:
```json
{
  "type": "AI_RESULT",
  "task_id": 1001,
  "camera_id": 3001,
  "scene_code": "REGION_INTRUSION",
  "ts": 1739426400000,
  "frame_width": 1920,
  "frame_height": 1080,
  "alarm_event": true,
  "confidence": 0.91,
  "objects": [
    {
      "label": "person",
      "score": 0.91,
      "bbox": [0.1, 0.2, 0.3, 0.4]
    }
  ],
  "snapshot_path": "/static/snapshots/task_1001/2026-02-13-14-30-00.jpg"
}
```

**算法节点 -> 平台 (多场景结果)**:
```json
{
  "type": "AI_RESULT",
  "task_id": 1001,
  "camera_id": 3001,
  "ts": 1739426400000,
  "frame_width": 1920,
  "frame_height": 1080,
  "snapshot_path": "/static/snapshots/task_1001/2026-02-13-14-30-00.jpg",
  "results": [
    {
      "scene_code": "REGION_INTRUSION",
      "alarm_event": true,
      "confidence": 0.91,
      "objects": [...]
    },
    {
      "scene_code": "HELMET_DETECTION",
      "alarm_event": false,
      "confidence": 0.87,
      "objects": [...]
    }
  ]
}
```

#### 15.5 预览控制消息

**平台 -> 算法节点 (开始预览)**:
```json
{
  "type": "START_PREVIEW",
  "data": {
    "task_id": 1001,
    "preview_path": "ai_task_1001",
    "fps": 15,
    "draw": true,
    "encoder": "h264_nvenc",
    "bitrate": "3000k",
    "preview_mode": "RESULT_DRIVEN",
    "width": 1280,
    "height": 720
  }
}
```

**平台 -> 算法节点 (停止预览)**:
```json
{
  "type": "STOP_PREVIEW",
  "data": {
    "task_id": 1001
  }
}
```

### 16. 结果处理与告警推送

#### 16.1 场景最新态表

```sql
DROP TABLE IF EXISTS `ai_task_scene_state`;
CREATE TABLE `ai_task_scene_state` (
  `task_id`             BIGINT NOT NULL COMMENT '任务ID',
  `camera_id`           BIGINT NOT NULL COMMENT '相机ID',
  `scene_code`          VARCHAR(50) NOT NULL COMMENT '场景编码',
  `scene_type_id`       BIGINT DEFAULT NULL COMMENT '场景类型ID',
  
  -- 最新结果
  `last_ts`             BIGINT NOT NULL COMMENT '最新时间戳',
  `last_time`           DATETIME NOT NULL COMMENT '最新时间',
  `event_type`          VARCHAR(20) DEFAULT NULL COMMENT '事件类型',
  `event_desc`          VARCHAR(255) DEFAULT NULL COMMENT '事件描述',
  `alarm_event`         TINYINT DEFAULT 0 COMMENT '是否告警',
  `total_count`         INT DEFAULT 0 COMMENT '检测总数',
  
  -- 统计信息
  `label_counts_json`   JSON DEFAULT NULL COMMENT '标签计数',
  `problem_counts_json` JSON DEFAULT NULL COMMENT '问题计数',
  `metrics_json`        JSON DEFAULT NULL COMMENT '指标信息',
  `last_snapshot_path`  VARCHAR(500) DEFAULT NULL COMMENT '最新快照',
  
  `update_time`         DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  
  PRIMARY KEY (`task_id`, `scene_code`),
  KEY `idx_camera_alarm` (`camera_id`, `alarm_event`),
  KEY `idx_update_time` (`update_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='场景最新态表';
```

**JSON 字段示例**:

```json
{
  "label_counts_json": {
    "person": 3,
    "vehicle": 1
  },
  "problem_counts_json": {
    "no_helmet": 2
  },
  "metrics_json": {
    "avg_confidence": 0.87,
    "max_confidence": 0.94
  }
}
```

#### 16.2 检测结果表

```sql
DROP TABLE IF EXISTS `ai_detection_result`;
CREATE TABLE `ai_detection_result` (
  `id`                 BIGINT NOT NULL AUTO_INCREMENT,
  `task_id`            BIGINT NOT NULL COMMENT '任务ID',
  `camera_id`          BIGINT NOT NULL COMMENT '相机ID',
  `group_id`           BIGINT DEFAULT NULL COMMENT '分组ID',
  `scene_type_id`      BIGINT DEFAULT NULL COMMENT '场景类型ID',
  `scene_code`         VARCHAR(50) DEFAULT NULL COMMENT '场景编码',
  `node_id`            VARCHAR(100) DEFAULT NULL COMMENT '节点ID',
  
  -- 检测时间
  `detect_time`        DATETIME NOT NULL COMMENT '检测时间',
  `detect_timestamp`   BIGINT NOT NULL COMMENT '检测时间戳',
  
  -- 告警信息
  `is_alarm`           TINYINT DEFAULT 0 COMMENT '是否告警',
  `alarm_level`        TINYINT DEFAULT 0 COMMENT '告警等级',
  `confidence`         FLOAT DEFAULT NULL COMMENT '置信度',
  `detect_count`       INT DEFAULT 0 COMMENT '检测数量',
  
  -- 检测结果
  `objects_json`       JSON DEFAULT NULL COMMENT '检测对象',
  `event_type`         VARCHAR(20) DEFAULT NULL COMMENT '事件类型',
  `event_desc`         VARCHAR(255) DEFAULT NULL COMMENT '事件描述',
  `total_count`        INT DEFAULT NULL COMMENT '总数',
  `label_counts_json`  JSON DEFAULT NULL COMMENT '标签计数',
  `problem_counts_json` JSON DEFAULT NULL COMMENT '问题计数',
  `metrics_json`       JSON DEFAULT NULL COMMENT '指标',
  
  -- 快照
  `snapshot_path`      VARCHAR(500) DEFAULT NULL COMMENT '快照路径',
  
  -- 推送状态
  `is_pushed`          TINYINT DEFAULT 0 COMMENT '是否已推送',
  `push_time`          DATETIME DEFAULT NULL COMMENT '推送时间',
  
  `create_time`        DATETIME DEFAULT CURRENT_TIMESTAMP,
  
  PRIMARY KEY (`id`),
  KEY `idx_task_time` (`task_id`, `detect_time`),
  KEY `idx_alarm_scene_group_time` (`is_alarm`, `scene_code`, `group_id`, `detect_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='检测结果表';
```

#### 16.3 结果处理流水线

```java
@Service
@Slf4j
public class AiResultProcessorService {
    
    @Resource
    private TaskSceneStateService sceneStateService;
    
    @Resource
    private DetectionResultService detectionResultService;
    
    @Resource
    private AlarmPushService alarmPushService;
    
    @Resource
    private WebNotifySocket webNotifySocket;
    
    private final BlockingQueue<JSONObject> resultQueue = 
        new LinkedBlockingQueue<>(20000);
    
    private final ExecutorService processExecutor;
    
    // 抽样控制
    private final ConcurrentHashMap<String, Long> sampleCache = new ConcurrentHashMap<>();
    
    @Value("${ai.result.sample-interval-ms:1000}")
    private long sampleIntervalMs;
    
    public AiResultProcessorService() {
        int coreThreads = Runtime.getRuntime().availableProcessors();
        this.processExecutor = new ThreadPoolExecutor(
            coreThreads,
            coreThreads * 2,
            60L, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(1000),
            new ThreadFactoryBuilder().setNameFormat("result-processor-%d").build(),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );
        
        // 启动处理线程
        for (int i = 0; i < coreThreads; i++) {
            processExecutor.submit(this::processLoop);
        }
    }
    
    /**
     * 提交结果到队列
     */
    public void submit(JSONObject resultMsg) {
        boolean alarm = resultMsg.getBooleanValue("alarm_event");
        
        boolean offered = resultQueue.offer(resultMsg);
        
        if (!offered) {
            if (!alarm) {
                // 非告警直接丢弃
                log.warn("Result queue full, dropping non-alarm event");
                return;
            }
            
            // 告警消息强插
            int tries = 0;
            while (!offered && tries++ < 10) {
                resultQueue.poll(); // 淘汰队头
                offered = resultQueue.offer(resultMsg);
            }
            
            if (!offered) {
                log.error("Failed to enqueue alarm event after retries");
            }
        }
    }
    
    /**
     * 处理循环
     */
    private void processLoop() {
        while (!Thread.currentThread().isInterrupted()) {
            try {
                JSONObject msg = resultQueue.poll(1, TimeUnit.SECONDS);
                if (msg != null) {
                    processResult(msg);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            } catch (Exception e) {
                log.error("Result processing error", e);
            }
        }
    }
    
    /**
     * 处理单条结果
     */
    private void processResult(JSONObject msg) {
        Long taskId = msg.getLong("task_id");
        Long cameraId = msg.getLong("camera_id");
        Long ts = msg.getLong("ts");
        String snapshotPath = msg.getString("snapshot_path");
        
        // 兼容单场景和多场景
        JSONArray resultsArray = msg.getJSONArray("results");
        
        if (resultsArray != null && !resultsArray.isEmpty()) {
            // 多场景结果
            for (int i = 0; i < resultsArray.size(); i++) {
                JSONObject sceneResult = resultsArray.getJSONObject(i);
                processSceneResult(taskId, cameraId, ts, snapshotPath, sceneResult);
            }
        } else {
            // 单场景结果
            processSceneResult(taskId, cameraId, ts, snapshotPath, msg);
        }
    }
    
    private void processSceneResult(Long taskId, Long cameraId, Long ts, 
                                     String snapshotPath, JSONObject sceneResult) {
        
        String sceneCode = sceneResult.getString("scene_code");
        Boolean alarmEvent = sceneResult.getBoolean("alarm_event");
        
        // 1. 更新最新态 (总是执行)
        sceneStateService.updateState(taskId, cameraId, sceneCode, ts, sceneResult);
        
        // 2. 判断是否需要持久化
        if (StringUtils.isBlank(snapshotPath)) {
            // 无快照,仅更新状态
            return;
        }
        
        if (!Boolean.TRUE.equals(alarmEvent)) {
            // 非告警,抽样
            if (!shouldSample(taskId, sceneCode, ts)) {
                return;
            }
        }
        
        // 3. 持久化结果
        DetectionResult result = buildDetectionResult(
            taskId, cameraId, sceneCode, ts, snapshotPath, sceneResult
        );
        
        detectionResultService.save(result);
        
        // 4. 告警推送
        if (Boolean.TRUE.equals(alarmEvent)) {
            alarmPushService.onAlarmDetected(result, sceneCode);
        }
    }
    
    /**
     * 抽样判断
     */
    private boolean shouldSample(Long taskId, String sceneCode, Long ts) {
        String key = taskId + ":" + sceneCode;
        Long lastTs = sampleCache.get(key);
        
        if (lastTs == null || (ts - lastTs) >= sampleIntervalMs) {
            sampleCache.put(key, ts);
            return true;
        }
        
        return false;
    }
    
    private DetectionResult buildDetectionResult(Long taskId, Long cameraId, 
                                                  String sceneCode, Long ts,
                                                  String snapshotPath,
                                                  JSONObject sceneResult) {
        
        DetectionResult result = new DetectionResult();
        result.setTaskId(taskId);
        result.setCameraId(cameraId);
        result.setSceneCode(sceneCode);
        result.setDetectTimestamp(ts);
        result.setDetectTime(LocalDateTime.ofInstant(
            Instant.ofEpochMilli(ts),
            ZoneId.systemDefault()
        ));
        result.setIsAlarm(sceneResult.getBoolean("alarm_event") ? 1 : 0);
        result.setConfidence(sceneResult.getFloat("confidence"));
        result.setObjectsJson(sceneResult.getJSONArray("objects").toJSONString());
        result.setSnapshotPath(snapshotPath);
        result.setEventType(sceneResult.getString("event_type"));
        result.setEventDesc(sceneResult.getString("event_desc"));
        result.setTotalCount(sceneResult.getInteger("total_count"));
        
        return result;
    }
}
```

**处理流程图**:

```
[算法结果] → [快路径: WebSocket推送前端] → [实时框显示]
            ↓
         [慢路径]
            ↓
      [抽样判断]
            ↓
    [有快照?] ──NO→ [仅更新最新态]
        │
       YES
        ↓
    [告警?] ──NO→ [抽样入库]
        │
       YES
        ↓
    [入库] → [告警推送]
```

#### 16.4 告警推送服务

```java
@Service
@Slf4j
public class AlarmPushService {
    
    @Resource
    private AiTaskRepository taskRepository;
    
    @Resource
    private AlarmPushConfigService configService;
    
    @Resource
    private AlarmPushLogRepository pushLogRepository;
    
    private final BlockingQueue<PushTask> pushQueue = new LinkedBlockingQueue<>(20000);
    
    private final ExecutorService pushExecutor;
    
    // 推送桶 (用于聚合推送)
    private final ConcurrentHashMap<String, PushBucket> buckets = new ConcurrentHashMap<>();
    
    public AlarmPushService() {
        this.pushExecutor = Executors.newFixedThreadPool(4,
            new ThreadFactoryBuilder().setNameFormat("alarm-push-%d").build());
        
        // 启动推送线程
        for (int i = 0; i < 4; i++) {
            pushExecutor.submit(this::pushLoop);
        }
        
        // 启动桶刷新线程
        Executors.newSingleThreadScheduledExecutor()
            .scheduleAtFixedRate(this::flushBuckets, 1, 1, TimeUnit.SECONDS);
    }
    
    public void onAlarmDetected(DetectionResult result, String sceneCode) {
        AiTask task = taskRepository.findById(result.getTaskId()).orElse(null);
        if (task == null) return;
        
        // 获取推送策略
        PushStrategy strategy = resolvePushStrategy(task);
        
        if ("IMMEDIATE".equals(strategy.getMode())) {
            // 立即推送
            pushQueue.offer(new PushTask(result, task, sceneCode));
        } else {
            // 聚合推送
            addToBucket(result, task, sceneCode, strategy);
        }
    }
    
    private void addToBucket(DetectionResult result, AiTask task, 
                             String sceneCode, PushStrategy strategy) {
        
        String bucketKey = task.getId() + ":" + sceneCode;
        
        PushBucket bucket = buckets.computeIfAbsent(bucketKey, 
            k -> new PushBucket(task, sceneCode, strategy));
        
        bucket.add(result);
    }
    
    private void flushBuckets() {
        long now = System.currentTimeMillis();
        
        buckets.values().forEach(bucket -> {
            if (bucket.shouldFlush(now)) {
                List<DetectionResult> results = bucket.flush();
                if (!results.isEmpty()) {
                    pushQueue.offer(new PushTask(results, bucket.task, bucket.sceneCode));
                }
            }
        });
    }
    
    private void pushLoop() {
        while (!Thread.currentThread().isInterrupted()) {
            try {
                PushTask task = pushQueue.poll(1, TimeUnit.SECONDS);
                if (task != null) {
                    executePush(task);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            } catch (Exception e) {
                log.error("Push execution error", e);
            }
        }
    }
    
    private void executePush(PushTask task) {
        try {
            // 构建推送内容
            String content = buildPushContent(task);
            
            // 调用飞书/企业微信等 API
            PushResponse response = sendToPushService(task.task.getPushRouteKey(), content);
            
            // 记录日志
            AlarmPushLog log = new AlarmPushLog();
            log.setConfigId(0L);
            log.setDetectionResultIds(JSON.toJSONString(
                task.results.stream().map(DetectionResult::getId).collect(Collectors.toList())
            ));
            log.setPushChannel("feishu");
            log.setPushTarget(task.task.getPushRouteKey());
            log.setPushContent(content);
            log.setPushStatus(response.isSuccess() ? 1 : 0);
            log.setResponseCode(response.getCode());
            log.setResponseMessage(response.getMessage());
            log.setPushTime(LocalDateTime.now());
            
            pushLogRepository.save(log);
            
            // 更新结果推送状态
            if (response.isSuccess()) {
                task.results.forEach(r -> {
                    r.setIsPushed(1);
                    r.setPushTime(LocalDateTime.now());
                });
            }
            
        } catch (Exception e) {
            log.error("Push failed for task {}", task.task.getId(), e);
        }
    }
    
    private String buildPushContent(PushTask task) {
        StringBuilder content = new StringBuilder();
        content.append("【告警通知】\n");
        content.append("相机: ").append(task.task.getCameraName()).append("\n");
        content.append("场景: ").append(task.sceneCode).append("\n");
        content.append("时间: ").append(LocalDateTime.now().format(
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")
        )).append("\n");
        content.append("检测数量: ").append(task.results.size()).append("\n");
        
        return content.toString();
    }
    
    private PushResponse sendToPushService(String routeKey, String content) {
        // 实际推送逻辑
        // 这里简化处理
        return new PushResponse(true, 200, "success");
    }
    
    private PushStrategy resolvePushStrategy(AiTask task) {
        // 简化实现
        return new PushStrategy(
            task.getPushMode() != null ? task.getPushMode() : "IMMEDIATE",
            task.getPushThresholdCount() != null ? task.getPushThresholdCount() : 1,
            task.getPushWindowSeconds() != null ? task.getPushWindowSeconds() : 60,
            task.getPushCooldownSeconds() != null ? task.getPushCooldownSeconds() : 0
        );
    }
}

@Data
@AllArgsConstructor
class PushTask {
    private List<DetectionResult> results;
    private AiTask task;
    private String sceneCode;
    
    public PushTask(DetectionResult result, AiTask task, String sceneCode) {
        this.results = Collections.singletonList(result);
        this.task = task;
        this.sceneCode = sceneCode;
    }
}

@Data
class PushBucket {
    private final AiTask task;
    private final String sceneCode;
    private final PushStrategy strategy;
    private final List<DetectionResult> results = new CopyOnWriteArrayList<>();
    private long firstAddTime;
    private long lastFlushTime;
    
    public PushBucket(AiTask task, String sceneCode, PushStrategy strategy) {
        this.task = task;
        this.sceneCode = sceneCode;
        this.strategy = strategy;
        this.firstAddTime = System.currentTimeMillis();
        this.lastFlushTime = System.currentTimeMillis();
    }
    
    public void add(DetectionResult result) {
        results.add(result);
        if (firstAddTime == 0) {
            firstAddTime = System.currentTimeMillis();
        }
    }
    
    public boolean shouldFlush(long now) {
        if (results.isEmpty()) return false;
        
        // 冷却期检查
        if (now - lastFlushTime < strategy.getCooldownSeconds() * 1000L) {
            return false;
        }
        
        String mode = strategy.getMode();
        
        if ("COUNT".equals(mode)) {
            return results.size() >= strategy.getThresholdCount();
        }
        
        if ("WINDOW".equals(mode)) {
            return (now - firstAddTime) >= strategy.getWindowSeconds() * 1000L;
        }
        
        if ("COUNT_OR_WINDOW".equals(mode)) {
            return results.size() >= strategy.getThresholdCount() ||
                   (now - firstAddTime) >= strategy.getWindowSeconds() * 1000L;
        }
        
        return false;
    }
    
    public List<DetectionResult> flush() {
        List<DetectionResult> flushed = new ArrayList<>(results);
        results.clear();
        firstAddTime = 0;
        lastFlushTime = System.currentTimeMillis();
        return flushed;
    }
}

@Data
@AllArgsConstructor
class PushStrategy {
    private String mode;
    private int thresholdCount;
    private int windowSeconds;
    private int cooldownSeconds;
}

@Data
@AllArgsConstructor
class PushResponse {
    private boolean success;
    private int code;
    private String message;
}
```

**推送模式说明**:

| 模式            | 触发条件         | 适用场景         |
| --------------- | ---------------- | ---------------- |
| IMMEDIATE       | 每次告警立即推送 | 高优先级告警     |
| COUNT           | 累计N次后推送    | 降低推送频率     |
| WINDOW          | 时间窗口到期推送 | 定期汇总         |
| COUNT_OR_WINDOW | 满足任一条件     | 兼顾实时性和聚合 |

------

### 17. 预览链路实现

#### 17.1 预览设计原则

1. **任务运行 ≠ 预览推流**
    - 任务可以运行但不推预览流
    - 预览流可以按需启停
2. **预览资源独立管理**
    - 预览占用编码器资源
    - 需要单独的生命周期控制
3. **预览地址动态生成**
    - 节点切换后地址需更新
    - 存储在运行态表

#### 17.2 预览控制服务

```java
@Service
@Slf4j
public class PreviewControlService {
    
    @Resource
    private TaskRuntimeRepository runtimeRepository;
    
    @Resource
    private EngineNodeRepository nodeRepository;
    
    @Resource
    private AiEngineSocket engineSocket;
    
    /**
     * 开始预览
     */
    @Transactional(rollbackFor = Exception.class)
    public void startPreview(StartPreviewRequest request) {
        // 1. 查询运行态
        TaskRuntime runtime = runtimeRepository.findById(request.getTaskId())
            .orElseThrow(() -> new NotFoundException("任务未运行"));
        
        if (!"RUNNING".equals(runtime.getState())) {
            throw new BusinessException("任务未运行,无法开启预览");
        }
        
        // 2. 构建预览路径
        String previewPath = request.getPreviewPath();
        if (StringUtils.isBlank(previewPath)) {
            previewPath = "ai_task_" + request.getTaskId();
        }
        
        // 3. 获取节点IP
        EngineNode node = nodeRepository.findByNodeId(runtime.getNodeId());
        if (node == null) {
            throw new BusinessException("节点不存在");
        }
        
        // 4. 构建播放地址
        String playUrl = String.format("http://%s:8889/%s", node.getIp(), previewPath);
        
        // 5. 发送预览命令
        JSONObject cmd = new JSONObject();
        cmd.put("type", "START_PREVIEW");
        
        JSONObject data = new JSONObject();
        data.put("task_id", request.getTaskId());
        data.put("preview_path", previewPath);
        data.put("fps", request.getFps() != null ? request.getFps() : 15);
        data.put("bitrate", request.getBitrate() != null ? request.getBitrate() : "3000k");
        data.put("width", request.getWidth() != null ? request.getWidth() : 1280);
        data.put("height", request.getHeight() != null ? request.getHeight() : 720);
        data.put("draw", request.getDraw() != null ? request.getDraw() : true);
        data.put("encoder", "h264_nvenc");
        data.put("preview_mode", "RESULT_DRIVEN");
        
        cmd.put("data", data);
        
        engineSocket.sendCommand(runtime.getNodeId(), cmd);
        
        // 6. 更新运行态
        runtime.setPreviewPath(previewPath);
        runtime.setPreviewPlayUrl(playUrl);
        runtimeRepository.updateById(runtime);
        
        log.info("Preview started: task={}, path={}, url={}", 
            request.getTaskId(), previewPath, playUrl);
    }
    
    /**
     * 停止预览
     */
    @Transactional(rollbackFor = Exception.class)
    public void stopPreview(Long taskId) {
        TaskRuntime runtime = runtimeRepository.findById(taskId)
            .orElseThrow(() -> new NotFoundException("任务运行态不存在"));
        
        if (StringUtils.isBlank(runtime.getPreviewPath())) {
            log.warn("Preview not started for task {}", taskId);
            return;
        }
        
        // 发送停止命令
        JSONObject cmd = new JSONObject();
        cmd.put("type", "STOP_PREVIEW");
        
        JSONObject data = new JSONObject();
        data.put("task_id", taskId);
        cmd.put("data", data);
        
        engineSocket.sendCommand(runtime.getNodeId(), cmd);
        
        // 清除运行态
        runtime.setPreviewPath(null);
        runtime.setPreviewPlayUrl(null);
        runtimeRepository.updateById(runtime);
        
        log.info("Preview stopped: task={}", taskId);
    }
    
    /**
     * 自动开启预览
     */
    public void autoStartPreview(Long taskId, String nodeId, String previewPath) {
        try {
            StartPreviewRequest request = new StartPreviewRequest();
            request.setTaskId(taskId);
            request.setPreviewPath(previewPath);
            request.setFps(15);
            request.setBitrate("3000k");
            request.setDraw(true);
            
            startPreview(request);
        } catch (Exception e) {
            log.error("Auto start preview failed for task {}", taskId, e);
        }
    }
}

@Data
class StartPreviewRequest {
    private Long taskId;
    private String previewPath;
    private Integer fps;
    private String bitrate;
    private Integer width;
    private Integer height;
    private Boolean draw;
}
```

#### 17.3 任务启停与预览联动

```java
@Service
@Slf4j
public class AiTaskService {
    
    @Resource
    private TaskDispatchService dispatchService;
    
    @Resource
    private TaskRuntimeService runtimeService;
    
    @Resource
    private TaskSceneRuntimeService sceneRuntimeService;
    
    @Resource
    private PreviewControlService previewService;
    
    @Resource
    private AiEngineSocket engineSocket;
    
    @Transactional(rollbackFor = Exception.class)
    public void startTask(Long taskId) {
        AiTask task = taskRepository.findById(taskId)
            .orElseThrow(() -> new NotFoundException("任务不存在"));
        
        // 1. 防重复启动
        TaskRuntime runtime = runtimeService.findById(taskId);
        if (runtime != null && isAliveRunning(runtime)) {
            log.warn("Task {} already running", taskId);
            return;
        }
        
        // 2. 解析场景编码
        List<String> sceneCodes = parseSceneCodes(task.getSceneCodes());
        if (sceneCodes.isEmpty()) {
            throw new BusinessException("任务未配置场景");
        }
        
        // 3. 生成调度计划
        DispatchPlan plan = dispatchService.buildDispatchPlan(task, sceneCodes);
        
        // 4. 创建运行态
        LocalDateTime now = LocalDateTime.now();
        int restartCount = (runtime != null) ? runtime.getRestartCount() + 1 : 0;
        
        runtimeService.upsertRunning(taskId, plan.getPrimaryNodeId(), now, restartCount);
        
        // 5. 启动任务
        Set<String> startedNodes = new LinkedHashSet<>();
        
        try {
            for (Map.Entry<String, List<String>> entry : plan.getNodeToScenes().entrySet()) {
                String nodeId = entry.getKey();
                List<String> scopedScenes = entry.getValue();
                
                // 发送启动命令
                JSONObject cmd = buildStartCommand(task, scopedScenes);
                engineSocket.sendCommand(nodeId, cmd);
                startedNodes.add(nodeId);
                
                // 更新场景运行态
                for (String sceneCode : scopedScenes) {
                    sceneRuntimeService.upsertRunning(taskId, sceneCode, nodeId, now, restartCount);
                }
            }
            
            // 6. 更新任务主表
            task.setStatus(1);
            task.setLastRunTime(now);
            taskRepository.updateById(task);
            
            // 7. 自动开启预览
            String previewPath = "ai_task_" + taskId;
            previewService.autoStartPreview(taskId, plan.getPrimaryNodeId(), previewPath);
            
            log.info("Task started: id={}, nodes={}", taskId, plan.getNodeToScenes().keySet());
            
        } catch (Exception e) {
            log.error("Task start failed: {}", taskId, e);
            
            // 回滚: 停止已启动节点
            for (String nodeId : startedNodes) {
                safeStopTask(nodeId, taskId);
            }
            
            // 标记失败
            runtimeService.markError(taskId, now);
            sceneRuntimeService.markErrorByTask(taskId, now, "START_TASK failed: " + e.getMessage());
            
            task.setStatus(2);
            task.setErrorMessage(e.getMessage());
            taskRepository.updateById(task);
            
            throw e;
        }
    }
    
    @Transactional(rollbackFor = Exception.class)
    public void stopTask(Long taskId) {
        AiTask task = taskRepository.findById(taskId)
            .orElseThrow(() -> new NotFoundException("任务不存在"));
        
        // 1. 停止预览
        try {
            previewService.stopPreview(taskId);
        } catch (Exception e) {
            log.error("Stop preview failed for task {}", taskId, e);
        }
        
        // 2. 查询运行节点
        List<String> nodeIds = sceneRuntimeService.findNodeIdsByTaskId(taskId);
        
        // 3. 发送停止命令
        for (String nodeId : nodeIds) {
            try {
                JSONObject cmd = new JSONObject();
                cmd.put("type", "STOP_TASK");
                
                JSONObject data = new JSONObject();
                data.put("task_id", taskId);
                cmd.put("data", data);
                
                engineSocket.sendCommand(nodeId, cmd);
            } catch (Exception e) {
                log.error("Stop task failed on node {}", nodeId, e);
            }
        }
        
        // 4. 更新运行态
        runtimeService.markStopped(taskId, LocalDateTime.now());
        sceneRuntimeService.markStoppedByTask(taskId, LocalDateTime.now());
        
        // 5. 更新任务主表
        task.setStatus(0);
        taskRepository.updateById(task);
        
        log.info("Task stopped: id={}", taskId);
    }
    
    private boolean isAliveRunning(TaskRuntime runtime) {
        if (!"RUNNING".equals(runtime.getState())) {
            return false;
        }
        
        if (runtime.getLastKeepalive() == null) {
            return false;
        }
        
        long elapsedSeconds = Duration.between(
            runtime.getLastKeepalive(),
            LocalDateTime.now()
        ).getSeconds();
        
        return elapsedSeconds < 30; // 30秒超时
    }
    
    private JSONObject buildStartCommand(AiTask task, List<String> sceneCodes) {
        JSONObject cmd = new JSONObject();
        cmd.put("type", "START_TASK");
        
        JSONObject data = new JSONObject();
        data.put("task_id", task.getId());
        data.put("camera_id", task.getCameraId());
        data.put("scene_codes", sceneCodes);
        data.put("stream_key", task.getCameraId() + ":" + task.getStreamType());
        data.put("rtsp", task.getRtspUrl());
        data.put("confThreshold", task.getConfThreshold());
        
        // 区域
        if (StringUtils.isNotBlank(task.getRegionJson())) {
            data.put("region", JSON.parseArray(task.getRegionJson()));
        }
        
        // 参数
        JSONObject params = new JSONObject();
        params.put("input_fps", task.getInputFps());
        params.put("in_w", task.getOutputWidth());
        params.put("in_h", task.getOutputHeight());
        params.put("result_fps", task.getOutputFps());
        params.put("quality", task.getProcessQuality());
        params.put("alarm_enabled", task.getAlarmEnabled());
        params.put("snapshot_policy", task.getSnapshotPolicy());
        params.put("snapshot_quality", task.getSnapshotQuality());
        
        data.put("params", params);
        cmd.put("data", data);
        
        return cmd;
    }
    
    private void safeStopTask(String nodeId, Long taskId) {
        try {
            JSONObject cmd = new JSONObject();
            cmd.put("type", "STOP_TASK");
            
            JSONObject data = new JSONObject();
            data.put("task_id", taskId);
            cmd.put("data", data);
            
            engineSocket.sendCommand(nodeId, cmd);
        } catch (Exception e) {
            log.error("Safe stop failed: node={}, task={}", nodeId, taskId, e);
        }
    }
    
    private List<String> parseSceneCodes(String json) {
        if (StringUtils.isBlank(json)) {
            return Collections.emptyList();
        }
        
        try {
            return JSON.parseArray(json, String.class);
        } catch (Exception e) {
            log.error("Failed to parse scene codes: {}", json, e);
            return Collections.emptyList();
        }
    }
}
```

------

## 第四部分:运维与演进

### 18. 配置管理

#### 18.1 应用配置模板

```yaml
# application.yml
server:
  port: 8080

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/video_analysis?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
    username: root
    password: ${DB_PASSWORD}
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000

# 相机配置
camera:
  onboarding:
    async-enabled: true
    sync-timeout-ms: 15000
    duplicate-check:
      by-ip-port: true
  
  onvif:
    default-port: 80
    connect-timeout-ms: 3000
    read-timeout-ms: 5000
    heartbeat-timeout-ms: 3000
    soap:
      strict-fault-check: true
      allow-capability-fallback: true
  
  stream:
    naming: "cam_{ip}_ch{channel}_{subtype}"
    subtype-rule:
      main-min-width: 1280
    retry:
      register-max-attempts: 3
      register-backoff-ms: 1000
  
  health:
    check-interval-ms: 30000
    initial-delay-ms: 10000
    offline-alarm-threshold-sec: 180

# 编解码配置
codec:
  probe:
    ffprobe-bin: ffprobe
    timeout-ms: 3000
    max-concurrency: 8
  
  transcode:
    enabled: true
    assume-h265-when-unknown: true
    ffmpeg-bin: ffmpeg
    rtsp-transport: tcp
    stimeout-us: 5000000
    probesize: 5000000
    analyzeduration: 5000000
    x264:
      preset: veryfast
      crf: 23
      gop: 50
    enable-audio: false

# MediaMTX 配置
media:
  mtx:
    api-base-url: http://127.0.0.1:9997
    rtsp-port: 8554
    webrtc-port: 8889
    api:
      path-add: /v3/config/paths/add/
      path-get: /v3/config/paths/get/
      path-list: /v3/config/paths/list
      path-delete: /v3/config/paths/delete/

# 录像配置
recording:
  default:
    retention-days: 7
    segment-duration: 10m
    record-format: fmp4
  
  index:
    fixed-delay-ms: 30000
    scan-depth: 4
    lookback-hours: 24
  
  storage:
    refresh-interval-ms: 15000
    auto-switch-enabled: true
    migrate-batch-size: 20

# 算法任务配置
ai:
  task:
    keepalive-timeout-seconds: 30
    scene-keepalive-timeout-seconds: 30
    dedup-running-seconds: 10
  
  result:
    queue:
      size: 20000
    worker:
      min: 4
      max: 16
    sample-interval-ms: 1000
    batch:
      enabled: false
      size: 200
      flush-ms: 500
  
  preview:
    auto-start: true
    default-fps: 15
    default-width: 1280
    default-height: 720
    default-bitrate: 3000k
    default-encoder: h264_nvenc
  
  push:
    queue-size: 20000
    flush-ms: 1000
    routes-file: push_routes.json
    level-policy-file: level_policy.json

# WebSocket 配置
ws:
  ai-engine:
    endpoint: /ws/ai-engine
  web-notify:
    endpoint: /ws/web-notify
```

#### 18.2 MediaMTX 配置模板

```yaml
# mediamtx.yml
###############################################
# Global settings

# API
api: yes
apiAddress: :9997

# Metrics
metrics: yes
metricsAddress: :9998

###############################################
# RTSP server

rtsp: yes
rtspAddress: :8554
protocols: [tcp]
encryption: "no"
rtspAddress: :8554

###############################################
# WebRTC server

webrtc: yes
webrtcAddress: :8889
webrtcICEServers:
  - urls: [stun:stun.l.google.com:19302]

###############################################
# HLS server

hls: yes
hlsAddress: :8888
hlsAlwaysRemux: no
hlsVariant: lowLatency
hlsSegmentCount: 7
hlsSegmentDuration: 1s
hlsPartDuration: 200ms

###############################################
# Recording

record: no
recordPath: /recordings/%path/%Y-%m-%d/%H-%M-%S
recordFormat: fmp4
recordPartDuration: 1s
recordSegmentDuration: 10m
recordDeleteAfter: 7d

###############################################
# Path defaults

paths:
  all:
    sourceOnDemand: yes
    sourceOnDemandStartTimeout: 10s
    sourceOnDemandCloseAfter: 10s
    runOnDemandStartTimeout: 10s
    runOnDemandCloseAfter: 10s
```

#### 18.3 Docker Compose 部署模板

```yaml
version: "3.8"

services:
  mysql:
    image: mysql:8.0
    container_name: video-mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: video_analysis
      TZ: Asia/Shanghai
    ports:
      - "3306:3306"
    volumes:
      - ./data/mysql:/var/lib/mysql
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    command: --default-authentication-plugin=mysql_native_password

  mediamtx:
    image: bluenviron/mediamtx:latest
    container_name: video-mediamtx
    restart: always
    ports:
      - "8554:8554"   # RTSP
      - "8888:8888"   # HLS
      - "8889:8889"   # WebRTC
      - "9997:9997"   # API
      - "9998:9998"   # Metrics
    volumes:
      - ./mediamtx.yml:/mediamtx.yml
      - ./data/recordings:/recordings
    environment:
      TZ: Asia/Shanghai

  app:
    image: video-analysis-platform:latest
    container_name: video-app
    restart: always
    depends_on:
      - mysql
      - mediamtx
    ports:
      - "8080:8080"
    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/video_analysis?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
      SPRING_DATASOURCE_USERNAME: root
      SPRING_DATASOURCE_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MEDIA_MTX_API_BASE_URL: http://mediamtx:9997
      TZ: Asia/Shanghai
    volumes:
      - ./data/snapshots:/app/snapshots
      - ./logs:/app/logs

  nginx:
    image: nginx:alpine
    container_name: video-nginx
    restart: always
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./data/recordings:/usr/share/nginx/html/recordings
      - ./data/snapshots:/usr/share/nginx/html/snapshots
    depends_on:
      - app
```

---

### 19. 可观测性体系

#### 19.1 核心指标定义

**相机接入层**:
```
camera_onboarding_total               # 接入总数
camera_onboarding_success_total       # 接入成功数
camera_onboarding_duration_seconds    # 接入耗时
camera_online_count                   # 在线设备数
camera_offline_count                  # 离线设备数
camera_offline_event_duration_seconds # 离线时长
```

**流媒体层**:
```
stream_path_total                     # 路径总数
stream_path_register_success_rate     # 注册成功率
stream_transcode_count                # 转码路数
media_gateway_request_duration_seconds # API 调用耗时
```

**录像层**:
```
recording_plan_active_count           # 活跃计划数
recording_file_index_lag_seconds      # 索引延迟
storage_volume_usage_percent          # 存储使用率
storage_volume_full_count             # 满盘卷数
```

**算法层**:
```
ai_task_running_count                 # 运行中任务数
ai_task_error_count                   # 异常任务数
ai_engine_online_nodes                # 在线节点数
ai_result_queue_depth                 # 结果队列深度
ai_result_drop_total                  # 丢弃结果数
ai_alarm_push_success_rate            # 推送成功率
```

#### 19.2 Prometheus 指标暴露

```java
@Component
public class MetricsCollector {
    
    private final Counter cameraOnboardingTotal;
    private final Counter cameraOnboardingSuccess;
    private final Histogram cameraOnboardingDuration;
    private final Gauge cameraOnlineCount;
    private final Gauge cameraOfflineCount;
    
    public MetricsCollector(MeterRegistry registry) {
        this.cameraOnboardingTotal = Counter.builder("camera_onboarding_total")
            .description("Total camera onboarding attempts")
            .register(registry);
        
        this.cameraOnboardingSuccess = Counter.builder("camera_onboarding_success_total")
            .description("Successful camera onboardings")
            .register(registry);
        
        this.cameraOnboardingDuration = Histogram.builder("camera_onboarding_duration_seconds")
            .description("Camera onboarding duration")
            .register(registry);
        
        this.cameraOnlineCount = Gauge.builder("camera_online_count", this::getOnlineCount)
            .description("Online camera count")
            .register(registry);
        
        this.cameraOfflineCount = Gauge.builder("camera_offline_count", this::getOfflineCount)
            .description("Offline camera count")
            .register(registry);
    }
    
    public void recordOnboardingAttempt() {
        cameraOnboardingTotal.increment();
    }
    
    public void recordOnboardingSuccess(long durationMs) {
        cameraOnboardingSuccess.increment();
        cameraOnboardingDuration.record(durationMs / 1000.0);
    }
    
    private double getOnlineCount() {
        return cameraRepository.countByStatus(1);
    }
    
    private double getOfflineCount() {
        return cameraRepository.countByStatus(0);
    }
}
```

#### 19.3 告警规则模板

```yaml
# prometheus-alerts.yml
groups:
  - name: camera_alerts
    interval: 30s
    rules:
      - alert: CameraOnboardingFailureRateHigh
        expr: |
          (
            rate(camera_onboarding_total[5m]) - 
            rate(camera_onboarding_success_total[5m])
          ) / rate(camera_onboarding_total[5m]) > 0.05
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "相机接入失败率过高"
          description: "过去 5 分钟接入失败率超过 5%"
      
      - alert: CameraOfflineCountHigh
        expr: camera_offline_count > 10
        for: 3m
        labels:
          severity: critical
        annotations:
          summary: "离线设备数量过多"
          description: "当前离线设备数: {{ $value }}"
  
  - name: storage_alerts
    interval: 30s
    rules:
      - alert: StorageVolumeAlmostFull
        expr: storage_volume_usage_percent > 90
        for: 3m
        labels:
          severity: warning
        annotations:
          summary: "存储卷即将满盘"
          description: "卷 {{ $labels.volume_id }} 使用率: {{ $value }}%"
      
      - alert: RecordingIndexLagHigh
        expr: recording_file_index_lag_seconds > 120
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "录像索引延迟过高"
          description: "索引延迟: {{ $value }} 秒"
  
  - name: ai_alerts
    interval: 30s
    rules:
      - alert: AiResultQueueFull
        expr: ai_result_queue_depth > 18000
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "结果队列即将满"
          description: "队列深度: {{ $value }}"
      
      - alert: AlarmPushFailureRateHigh
        expr: ai_alarm_push_success_rate < 0.95
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "告警推送成功率过低"
          description: "成功率: {{ $value }}"
```

#### 19.4 日志规范

**日志级别使用**:
- ERROR: 系统异常,需要人工介入
- WARN: 降级或重试成功的场景
- INFO: 关键业务事件 (接入成功、任务启动等)
- DEBUG: 详细调试信息

**日志格式**:
```
[时间] [级别] [线程] [类名] - [业务标识] 消息内容
```

**示例**:
```
2026-02-13 14:30:00.123 INFO  [main] c.e.CameraOnboardingService - [camera:1001] Device onboarded successfully: ip=10.0.1.20, manufacturer=Hikvision
2026-02-13 14:30:05.456 WARN  [task-1] c.e.MediaPathService - [path:cam_10_0_1_20_ch1_main] MediaMTX registration failed, retrying (1/3)
2026-02-13 14:30:10.789 ERROR [task-2] c.e.OnvifManager - [camera:1002] ONVIF connection timeout: ip=10.0.1.21, timeout=3000ms
```

---

### 20. 典型问题与解决方案

#### 20.1 设备接入层

**问题 1: ONVIF 连接超时**

现象:
```
OnvifException: Connection timeout after 3000ms
```

排查步骤:
1. `ping` 设备 IP 确认网络连通性
2. `telnet ip 80` 确认端口开放
3. 浏览器访问 `http://ip/onvif/device_service` 验证服务
4. 检查防火墙规则

解决方案:
- 增加超时时间至 5-10 秒
- 配置网络路由
- 使用设备 Web 界面开启 ONVIF 服务

**问题 2: WS-Security 认证失败**

现象:
```
SOAP Fault: The security token could not be authenticated
```

原因: 服务器与设备时间误差 > 5 秒

解决方案:

```bash
# 服务器端同步 NTP
ntpdate ntp.aliyun.com

# 设备端配置 NTP
设备 Web 界面 -> 系统配置 -> 时间设置 -> NTP 服务器: ntp.aliyun.com
```

**问题 3: 在线但无画面**

现象: `camera_status=1`, 但 RTSP 拉流失败

原因: 控制面可达但媒体面不可达

解决方案:

```java
// 增加媒体可用性检查
public boolean checkMediaAvailable(String rtspUrl) {
    try {
        ProcessBuilder pb = new ProcessBuilder(
            "ffmpeg", "-i", rtspUrl, 
            "-t", "1", "-f", "null", "-"
        );
        Process p = pb.start();
        return p.waitFor(5, TimeUnit.SECONDS) && p.exitValue() == 0;
    } catch (Exception e) {
        return false;
    }
}
```

#### 20.2 录像层

**问题 4: 计划显示已开启但无文件**

排查步骤:

1. 检查 `recording_plan.status` 是否为 1
2. 检查 MediaMTX 路径配置: `GET /v3/config/paths/get/{pathName}`
3. 检查存储卷状态: `storage_volume.status` 和 `is_full`
4. 检查源 RTSP 可拉流性

解决方案:

```java
// 增加健康检查
@Scheduled(fixedDelay = 60000)
public void checkRecordingHealth() {
    List<RecordingPlan> plans = planRepository.findByStatus(1);
    
    for (RecordingPlan plan : plans) {
        // 检查最近 5 分钟是否有新文件
        long recentFileCount = fileRepository.countByStreamNameAndTimeSince(
            plan.getStreamName(),
            LocalDateTime.now().minusMinutes(5)
        );
        
        if (recentFileCount == 0) {
            log.warn("No recent files for plan {}, reapplying config", plan.getId());
            planService.applyPlan(plan.toRequest());
        }
    }
}
```

**问题 5: 回放查询有空洞**

现象: 物理文件存在,数据库查不到

原因: 索引任务只扫描最近窗口,漏扫历史补写文件

解决方案:

```java
// 增加全量补扫任务
@Scheduled(cron = "0 0 2 * * ?") // 每天凌晨 2 点
public void fullScan() {
    List<StorageVolume> volumes = volumeRepository.findByStatus(1);
    
    for (StorageVolume volume : volumes) {
        scanVolumeFullRange(volume);
    }
}
```

#### 20.3 算法层

**问题 6: 任务显示运行中,但算法端无负载**

排查步骤:

1. 检查 `ai_task_runtime.state` 是否真的为 `RUNNING`
2. 检查节点 WebSocket 会话是否在线
3. 检查算法端日志是否收到 `START_TASK` 命令
4. 检查 `TASK_KEEPALIVE` 心跳上报

解决方案:

```java
// 增加守护任务
@Scheduled(fixedDelay = 10000)
public void watchdogTask() {
    List<TaskRuntime> runtimes = runtimeRepository.findByState("RUNNING");
    
    for (TaskRuntime runtime : runtimes) {
        long elapsed = Duration.between(
            runtime.getLastKeepalive(),
            LocalDateTime.now()
        ).getSeconds();
        
        if (elapsed > 30) {
            log.warn("Task {} keepalive timeout, marking ERROR", runtime.getTaskId());
            runtime.setState("ERROR");
            runtimeRepository.updateById(runtime);
            
            // 通知节点断连处理
            onNodeDisconnected(runtime.getNodeId());
        }
    }
}
```

**问题 7: 结果队列堆积**

现象: `ai_result_queue_depth` 持续增长,内存告警

原因: 处理速度跟不上生产速度

解决方案:

```java
// 1. 启用非告警抽样
@Value("${ai.result.sample-interval-ms:1000}")
private long sampleIntervalMs;

// 2. 启用批量入库
@Value("${ai.result.batch.enabled:false}")
private boolean batchEnabled;

@Value("${ai.result.batch.size:200}")
private int batchSize;

// 3. 增加处理线程
int coreThreads = Runtime.getRuntime().availableProcessors();
this.processExecutor = new ThreadPoolExecutor(
    coreThreads * 2,  // 增加并发
    coreThreads * 4,
    60L, TimeUnit.SECONDS,
    new LinkedBlockingQueue<>(1000)
);
```

---

### 21. FAQ 与最佳实践

#### 21.1 相机接入

**Q: 是否必须支持 ONVIF?**

A: 不是必须,但强烈建议。ONVIF 提供标准化的设备管理和流获取方式。不支持 ONVIF 的设备可以通过厂商兜底模式接入,但需要手动维护 RTSP 模板。

**Q: 如何处理厂商差异?**

A: 分层处理:
1. 协议层做最大兼容 (Fault 解析、能力降级)
2. 业务层提供厂商兜底开关
3. 配置层维护厂商 RTSP 模板库

**Q: 主码流和子码流如何选择?**

A: 建议策略:
- 录像: 主码流
- 实时预览: 子码流
- 算法分析: 根据精度要求选择

#### 21.2 流媒体

**Q: 为什么推荐 MediaMTX 而不是 ZLMediaKit?**

A: 两者都是优秀的开源方案,选择 MediaMTX 的原因:
1. 单一二进制,部署简单
2. RESTful API 设计现代化
3. WebRTC 支持原生
4. 社区活跃,文档完善

**Q: H.265 一定要转码吗?**

A: 不是。建议策略:
- 浏览器实时预览: 转 H.264
- 录像存储: 保留 H.265 (节省空间)
- 算法分析: 视算法输入要求而定

**Q: 转码会增加多少延迟?**

A: 软件转码: 1-3 秒
硬件转码 (NVENC): 500ms-1 秒

#### 21.3 录像

**Q: 切片时长怎么选?**

A: 综合考虑:
- 1-2 分钟: 文件数量大,IO 压力高
- 5-10 分钟: 推荐,综合最优
- 30-60 分钟: 文件少,但回放拖拽粗糙

**Q: FMP4 vs TS 格式?**

A: FMP4 优势:
- 现代浏览器原生支持
- 元数据结构清晰
- 后期处理友好

TS 优势:
- 兼容性更广 (老设备/老浏览器)
- 容错性强 (部分损坏不影响播放)

**Q: 如何避免磁盘满导致录像中断?**

A: 多层防护:
1. 水位线机制自动切卷
2. 定时清理过期文件
3. 磁盘使用率告警
4. 降级策略 (关闭非关键路径录像)

#### 21.4 算法

**Q: 一个任务可以配置多少个场景?**

A: 理论无上限,实际建议:
- 单节点模式: 3-5 个
- 拆分模式: 5-10 个

过多场景会导致:
- 推理开销增加
- 结果处理复杂
- 告警频率过高

**Q: 任务失败如何重试?**

A: 分级重试:
1. 瞬时失败 (网络抖动): 自动重启,计数器 +1
2. 持续失败 (设备离线): 标记 ERROR,等待设备恢复
3. 配置错误: 不重试,需要人工修复

**Q: 如何控制告警推送频率?**

A: 使用推送模式:
- 高优先级: `IMMEDIATE`
- 中优先级: `COUNT=5, WINDOW=600s`
- 低优先级: `WINDOW=3600s`

并配合冷却期避免风暴。

---

### 22. 性能基准与压测

#### 22.1 接入性能基准

**测试环境**:
- CPU: 8C16G
- 网络: 千兆局域网
- 设备: 海康威视 DS-2CD2142FWD-I

**测试结果**:

| 并发数 | 接入成功率 | P50 耗时 | P95 耗时 | P99 耗时 |
| ------ | ---------- | -------- | -------- | -------- |
| 10     | 100%       | 850ms    | 1200ms   | 1500ms   |
| 50     | 99.2%      | 1100ms   | 1800ms   | 2400ms   |
| 100    | 97.5%      | 1450ms   | 2500ms   | 3200ms   |
| 200    | 94.8%      | 2100ms   | 3800ms   | 4800ms   |

**瓶颈分析**:
- 网络 I/O 是主要瓶颈
- ONVIF SOAP 解析占用 15-20% CPU
- FFprobe 探测占用 30-40% CPU

**优化建议**:
- 接入任务异步化
- FFprobe 并发限制 (信号量)
- 设备信息缓存

#### 22.2 录像性能基准

**测试环境**:
- CPU: 16C32G
- 存储: NVMe SSD
- 路数: 500 路并发录像

**测试结果**:

| 码率  | 切片时长 | 磁盘写入 | CPU 使用 | 内存使用 |
| ----- | -------- | -------- | -------- | -------- |
| 2Mbps | 10m      | 125MB/s  | 18%      | 4.2GB    |
| 4Mbps | 10m      | 250MB/s  | 22%      | 5.8GB    |
| 6Mbps | 10m      | 375MB/s  | 28%      | 7.5GB    |

**索引性能**:
- 扫描速度: 10000 文件/秒
- 索引延迟: P95 < 30 秒

#### 22.3 算法性能基准

**测试环境**:
- GPU: NVIDIA RTX 3080
- 算法: YOLOv8m
- 输入: 1280x720 @ 15fps

**单节点容量**:

| 场景数/任务 | 并发任务数 | GPU 使用 | 推理延迟 |
| ----------- | ---------- | -------- | -------- |
| 1           | 50         | 68%      | 45ms     |
| 2           | 35         | 72%      | 52ms     |
| 3           | 25         | 78%      | 61ms     |

**结果处理**:
- 队列吞吐: 20000 条/秒
- 入库延迟: P95 < 200ms
- 告警推送: P95 < 500ms

---

### 23. 架构演进路线

#### 23.1 当前架构 (v1.0)

**特点**:
- 单体应用
- MySQL 单实例
- 本地文件存储
- 单节点 MediaMTX

**适用场景**:
- 设备数 < 1000
- 并发流 < 200
- 算法任务 < 100

#### 23.2 中期演进 (v2.0)

**目标**: 支撑 5000 设备、1000 并发流

**改进点**:

1. **服务拆分**
```
   单体应用 → 接入服务 + 录像服务 + 算法服务
```

2. **存储优化**
```
   本地存储 → 对象存储 (MinIO/OSS)
   分层存储: 热数据 SSD + 冷数据 HDD
```

3. **MediaMTX 集群**
```
   单节点 → 多节点 + LVS 负载均衡
   路径哈希分片
```

4. **数据库读写分离**
```
   主库: 写入
   从库: 查询 + 统计
```

#### 23.3 长期演进 (v3.0)

**目标**: 支撑 10万+ 设备、万级并发流

**改进点**:

1. **微服务化**
```
   按业务域拆分:
   - 设备管理服务
   - 流媒体服务
   - 录像服务
   - 算法服务
   - 告警服务
   
   服务间通信: gRPC + MQ
```

2. **分布式存储**
```
   录像: Ceph 集群
   元数据: TiDB
   缓存: Redis 集群
```

3. **边缘计算**
```
   中心节点 + 边缘节点
   边缘: 实时分析 + 本地录像
   中心: 长期存储 + 全局调度
```

4. **云原生改造**
```
   容器化: Kubernetes
   服务网格: Istio
   可观测: Prometheus + Grafana + Jaeger
```

------

## 总结

本文从零开始,构建了一个完整的企业级视频智能分析平台,覆盖:

1. **相机接入**: ONVIF 协议深度实践、流路径治理、编码决策
2. **录像存储**: 存储卷管理、文件索引、回放检索
3. **智能分析**: 多场景任务模型、节点调度、结果处理、告警推送
4. **运维体系**: 配置管理、可观测性、问题排查、性能优化

**核心设计原则**:

- **分层解耦**: 控制面/媒体面、策略/执行、实时/批量
- **统一抽象**: 路径模型、场景模型、状态模型
- **容错优先**: 异步化、重试、降级、回滚
- **可观测**: 日志、指标、链路、告警

**技术栈总结**:

| 层次   | 技术选型                 |
| ------ | ------------------------ |
| 协议   | ONVIF (SOAP/WS-Security) |
| 流媒体 | MediaMTX                 |
| 编解码 | FFmpeg/FFprobe           |
| 存储   | MySQL + 文件系统         |
| 通信   | WebSocket + RESTful      |
| 监控   | Prometheus + Grafana     |